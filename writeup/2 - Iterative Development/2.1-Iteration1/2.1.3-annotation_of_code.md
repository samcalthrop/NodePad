# 2.1.3 - Annotation of Code

> _an overview & explanation of the code written to build this project - **this includes testing**_

_^Note that any time elipses `...` are used, it represents more code that isn't relevant to what I'm analysing, but is still in the file_

## Preface/ Configuration

Though this area isn't related to logic/ flow of the program, it's important to set it up right - I'll use `npm`/ `node` to install/ manage files and packages. These packages currently include:

- [electron](https://www.electronjs.org/) - provides the wrapper to embed chromium as a desktop app
- [react](https://react.dev/) - provides a framework for UI/ flow of the app
- [mantine](https://mantine.dev/) - a UI library for buttons, menus etc.
- Some core javascript libraries such as the `path` module

Furthermore, I'll be writing with Typescript in place of Javascript, so additional configuration is needed for transpilation. These are responsible for the majority of dotfiles, `.json` and `.yml` files in the [root](https://github.com/samcalthrop/NodePad) NodePad directory:

<img src="./src/dotfiles.png" />

Additionally, I will be using [VSCode](https://code.visualstudio.com/) to program the coded solution, as well as iTerm2 as my terminal of choice for version control etc.

Coming back to this later on in development:

> **In [Iteration 2](../2.2-Iteration2/2.2.1-aims.md), I switched to using [Zed](https://zed.dev/) as my IDE, which was a new, faster alternative to VSCode written in Rust. This was experimental, and not guaranteed to stay my main code editor, and my aim was to test its performance - VSCode was good, but became slow and bulky after building up the codebase significantly. As a result, I decided to stick with Zed, as it proved to be much faster, and even aesthetically nicer for me to use.**

### Conventions

Before I start programming, it's important I set out conventions to use throughout my codebase to make sure the code is _understandable, modifiable, robust, and, consistent_.

With regards to the layout of the project files, they fall into the following categories:

| Item             | Type     | Usage                                                                                                                                                    |
| ---------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `build/`         | `folder` | where the metadata is stored for when the app is built, e.g. the app icon                                                                                |
| `db/`            | `folder` | the store for the database I'm going to use in my app                                                                                                    |
| `documentation/` | `folder` | where I store the user and developer documentation with regards to using/ developing the app                                                             |
| `node_modules/`  | `folder` | a folder containing all the packages/ frameworks used to aid in building the app, e.g. Mantine                                                           |
| `out/`           | `folder` | the location given for all the output files - these are the compiled files used to run the app, produced when the commands `npm run`/`npm build` are run |
| `resources/`     | `folder` | where media used within the app, such as demo videos                                                                                                     |
| `src/`           | `folder` | where the entirety of the code written by me is stored                                                                                                   |
| `writeup/`       | `folder` | where the writeup is stored - _we are here_                                                                                                              |
| `README.md`      | `file`   | an introductory document briefing whoever enters the repository on what the repository is about and where to find everything                             |

#### `src/` Structure

Within the `src/` directory, the following folders/ files are delegated to different roles for maximum modularity and understandability for other programmers:

| Item                          | Type   | Usage                                                                                                                                                                                                                                                                                                                    |
| ----------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src/main/`                   | folder | a folder used to contain all files related to the app's backend                                                                                                                                                                                                                                                          |
| `src/main/index.ts`           | file   | the main entry point for the backend of the app - this includes starting the app up, and initialising variables such as window size                                                                                                                                                                                      |
| `src/preload/`                | folder | a folder symbolising the link between the backend and frontend - this is used by Electron to enforce security measures so that I don't have to manually. This does however mean I have to write more code to pass data from the frontend to the backend, using an intermediary step - this code is written here          |
| `src/preload/index.ts`        | file   | the entry point for the preload part of the app to be run                                                                                                                                                                                                                                                                |
| `src/renderer/`               | folder | a folder housing all the code for the frontend of the app. Since this is a significant amount of code, it's split up into the logical subcategories below                                                                                                                                                                |
| `src/renderer/index.html`     | file   | where the base HTML is written for the app, including metadata and a base for all components to sit on                                                                                                                                                                                                                   |
| `src/renderer/src/index.ts`   | file   | the main entry point for the frontend of the app, where all the code from `renderer/` is brought together                                                                                                                                                                                                                |
| `src/renderer/src/assets`     | folder | a folder containing all assets used in components, such as file icons in the file tree                                                                                                                                                                                                                                   |
| `src/renderer/src/components` | folder | a folder containing all the modular components used in the app. This not only makes my code easier to read, but means these components can be re-used in any part of the app, such as being able to use a theme selector component both in Settings and in the Welcome Screen without needing to rewrite any of the code |
| `src/renderer/src/providers`  | folder | a folder containing all providers used in the app - these are used to communicate data between all parts of the app at all times                                                                                                                                                                                         |
| `src/renderer/src/screens`    | folder | a folder containing code for all the 'screens' in the app - these are just the different views the user can navigate to within the app, e.g. the Home Screen                                                                                                                                                             |
| `src/renderer/src/types`      | folder | a folder containing the different custom types I've defined that are used in the app                                                                                                                                                                                                                                     |

##### Module Layout

Furthermore, to create each module, I aim to follow the same general pattern:

- Component Folder e.g. `HomeScreen/`
  - Component logic & structuring e.g. `HomeScreen.tsx`
  - Export file, always `index.ts`, used to export the component function from the `.tsx` file
  - Styling module, where component styles are determined, e.g. `HomeScreen.module.css`

A visual example is below:

```mermaid

flowchart LR

A['HomeScreen/'] --> B['HomeScreen.tsx']
A --> C['index.ts']
A --> D['HomeScreen.module.css']

```

I aim to keep this convention consistent throughout, which should make the codebase a lot cleaner and clearer for anyone viewing it, as it mimics conventions used in industry.

#### Code

Additionally, code should be consistent in its writing style, as well as being clear and concise. As I'm using TypeScript, I'm able to make use of [ESLint](https://eslint.org/) to use linting rules in order to keep my code to a certain standard throughout. Since the linting config files are included in the repository, this also means anyone else who downloads the repo will have to follow the same linting rules.

Some additional conventions that aren't caught by ESLint are:

- Curly brace `{}` indentation/ positioning - the opening bracket is written on the same line as the definition, and the trailing bracket has its own line below the content:

```ts
const x = (): void => {
  // content
};
```

- Functions and variables are by convention named with `camelCase` (starting with a lowercase letter):

```ts
const doSomething = (thisVariable: string): void => {
  // content
};
```

- Classes, Types, and JSX Elements are by convention named with `CamelCase` (starting with an uppercase letter):

```ts
class ThisClass {
  // content
}

type ThisType = {
  // content
};

function ThisElement = (): JSX.Element {
  // content
}
```

- Acronyms only have their first letter capitalised, and the rest are in lowercase:

```ts
const Tqbf: string = 'The Quick Brown Fox';
```

- Indents are equal to two line spaces in length:

```ts
if (a === b) {
  if (c === d) {
    if (e === f) {
      // content
    }
  }
}
```

# The App

The far majority of the code written is found within the [src](https://github.com/samcalthrop/NodePad/tree/main/src) directory. This is split into:

- [main](https://github.com/samcalthrop/NodePad/tree/main/src/main) - the backend
- [preload](https://github.com/samcalthrop/NodePad/tree/main/src/preload) - sets up Inter-Process Communication - essentially a bridge between the front and backend
- [renderer](https://github.com/samcalthrop/NodePad/tree/main/src/renderer) - the frontend

An expansion of how the three layers work together is below:

<img src='./src/appLayers.png' />

These layers communicate with each other via Inter-Process Communication (IPC) - this is used to isolate the frontend from the backend, making it much more difficult for bad actors to access important backend information. Electron provides the processes `IPCMain` and `IPCRenderer` that allow for this communication, making use of a `preload` script to make the app more secure by exposing the fewest sensitive APIs to the frontend as possible.

## App Setup

`src/main`, _at the time of writing this_, contains 2 files - [index.ts](https://github.com/samcalthrop/NodePad/blob/main/src/main/index.ts) and [getTreeNodeData.ts](https://github.com/samcalthrop/NodePad/blob/main/src/main/getTreeNodeData.ts).

[index.ts](https://github.com/samcalthrop/NodePad/blob/main/src/main/index.ts) is the access point for the backend code. A lot of this file is attributed to set up of the app:

The `createWindow()` function...

...defines how the window should appear, relative to the OS of the user:

```ts
const mainWindow = new BrowserWindow({
  width: 900,
  height: 670,
  show: false,
  autoHideMenuBar: true,
  ...(process.platform === 'linux' ? { icon } : {}),
  webPreferences: {
    preload: join(__dirname, '../preload/index.js'),
    sandbox: false,
  },
});
```

...makes the call to display the window to the user:

```ts
mainWindow.on('ready-to-show', () => {
  mainWindow.show();
});
```

...and handles customisation for different versions e.g opening `dev tools` if the user runs the app in `dev` mode using `npm run dev` in the command line:

```ts
mainWindow.webContents.openDevTools({ mode: 'right' });
```

Within `app.whenReady().then`, we can set the `createWindow()` function defined above to be called once the app is ready to be shown

For further setup, in `src/renderer/src` I have to define all the routes through the app (_e.g. which pages you can navigate to_). This is done in [index.tsx](https://github.com/samcalthrop/NodePad/blob/main/src/preload/index.ts):

`src/renderer/src/index.html`:

```tsx
ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <MantineProvider defaultColorScheme="dark" theme={theme}>
      <HashRouter>
        <Routes>
          <Route path="/" element={<Screen> </Screen>} />
          <Route path="/login" element={<LoginScreen />} />
          <Route path="/signup" element={<SignUpScreen />} />
          <Route path="/home" element={<HomeScreen />} />
          <Route path="/edit-node-meta" element={<EditNodeMetaScreen />} />
        </Routes>
      </HashRouter>
    </MantineProvider>
  </React.StrictMode>
);
```

where each `<Route/>` defines a path to a different Screen.

This is then paired with the `index.html` file found directly within the `renderer` directory, which is used to configure the base html/ meta information for the app, and telling the renderer where it can find the main code for the app:

`src/renderer/index.html`:

```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>NodePad</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://github.com/mdx-editor/editor; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
    />
  </head>

  <body>
    <div id="root"></div>
    <!-- defining where the renderer can find the main code for the app -->
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
```

### Testing

#### Test 1: Routes allow correct navigation through the app

**_NOTE: This was tested towards the end of the iteration, when most of the iteration's work was complete, as this test could only be undertaken once there was content in each section of the app. Therefore, the app looks much more complete at this stage than it actually is at this stage in development._**

| Description                                                                                                                                                                                 | Input                                                                                    | Output                                                                                    | Result                                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| The user should be able to navigate through the app exactly as [the routes are defined in Design Part 1 - User Flows](../../3%20-%20Design/3.1%20-%20Design%20Part%20I/3.1.4-user_flow.md). | Follow all paths through the app by clicking navigation buttons (_log in, sign up etc._) | See that all screens can be navigated to following the guideline defined in Design Part 1 | **Partial Success** ðŸŸ¨ - _all routes I've implemented work, however I haven't made the settings or edit modes yet, so obviously these can't be navigated to_ |

**Evidence:**

<div align="center">
  <img src="./src/userflow.gif" alt="User Flow Demo">
</div>

## Screens

In order to best modularise my code, I created a `screens` directory within `src/renderer/src` - that way I was able to build a base `screen`, from which I could build on top of for other screens. This sped up the development process, and also made the styling/ layout of the app more consistent and logical.

### Defining a base

The [base screen](https://github.com/samcalthrop/NodePad/blob/main/src/renderer/src/screens/Screen/Screen.tsx) was my solution to creating a simple base, mainly defining rules allowing it to be used by child screens (screens I build using this as a base).

To make this, I simply created a function to return a `<div/>` element containing all children passed into the element:

`Screen.tsx`:

```tsx
export const Screen = ({ children }: ScreenProps): JSX.Element => {
  return <div className={classes.root}>{children}</div>;
};
```

Which uses the `ScreenProps` type to allow the developer to pass in properties to the `<Screen/>` element:

`types/index.ts`:

```ts
export type ScreenProps = {
  children: ReactNode;
};
```

I gave it minimal styling given that this screen only needs to house child content, so the `Screen.module.css` file is very bare-bones:

```css
.root {
  margin: 10px;
  width: 100%;
  height: 100%;
}
```

#### Testing

There is no testing to be done for this screen, as it's only purpose is to provide a base for children screens.

#### The result

The result is a basic window from which I can build all screens on top of:

<img src='./src/screen.png' />

### Login

> _The [Login Screen](https://github.com/samcalthrop/NodePad/tree/main/src/renderer/src/screens/LoginScreen) is where the user is taken to enter valid credentials in order to be let into the main app._

For this screen I focused on making the skeleton for the login screen, rather than the backend processing of the data entered at this point - the form for the user to fill out, containing all username and password fields, as well as a submission button and a 'remember me' checkbox. I used [Mantine's documentation on their `<form/>` component](https://mantine.dev/form/use-form/) to build up the three fields with placeholders, labels, asterisks and a way for the form to submit all 3 fields simultaneously, by using the `key` attribute alongside a submission `<Button/>`. This is all contained within the `<Screen/>` component defined earlier:

```tsx
<Screen>
  ...
  <form onSubmit={form.onSubmit(() => navigate('/home'))}>
    {/* username field */}
    <TextInput
      withAsterisk
      label="Email"
      placeholder="your@email.com"
      key={form.key('email')}
      {...form.getInputProps('email')}
    />

    {/* password field */}
    <PasswordInput
      withAsterisk
      label="Password"
      description="ensure password length is at least 8 characters long"
      placeholder="password-123"
      key={form.key('password')}
      {...form.getInputProps('password')}
    />

    {/* 'remember me' checkbox */}
    <Checkbox
      mt="sm"
      label="remember me"
      key={form.key('remember')}
      {...form.getInputProps('remember', { type: 'checkbox' })}
    />

    {/* form submission */}
    <Group justify="flex-begin" mt="md">
      <Button type="submit">Submit</Button>
    </Group>
  </form>
  ...
</Screen>
```

_Note that since it's wrapped within the `<Screen>` element, it inherits whatever properties are applied to `<Screen>` automatically._

To make this form functional I used Mantine's `useForm()` hook to determine what properties the form should take...

```tsx
const form = useForm({
  initialValues: {
    email: '',
    password: '',
    remember: false,
  },
  ...
});
```

...and then wrote scripts to define how they should validate input:

```tsx
validate: {
  email: (value) => (/^\S+@\S+$/.test(value) ? null : 'Invalid email'),
  password: (value) => (value.length >= 8 ? null : 'Invalid email'),
},
```

A breakdown of the RegEx expressions for validation is below:

- The `email` validation uses the regular expression `/^\S+@\S+$/` as follows:
  - `^`: The pattern must start at the start if the user's input
  - `\S+`: `\S` matches any non-whitespace character, and `+` indicates any number of non-whitespace characters
  - `@`: Ensures there must be an '@' to separate the input
  - `\S+` (again): checks that there are characters on the other side of the '@'
  - `$`: Ensures no characters proceed the entered string of characters
- The `password` validation is currently much more primitive, only requiring the input be at least 8 characters long

Then a react hook is used to navigate to the homepage upon successful login, where `useNavigate()` is a hook provided by `react-router-dom`, and again to reroute the user to the Signup Screen if they're new:

```tsx
const navigate = useNavigate();
...
<form onSubmit={form.onSubmit(() => navigate('/home'))}>
  ...
</form>

<Button
  variant="transparent"
  className={classes.button}
  onClick={() => navigate('/signup')}
>
  Sign Up
</Button>
```

#### The result

The result of this code is a login page that looks like this:

<img src="./src/login.png"/>

#### Testing

##### Test 2: Navigation is correct

| Description                                                                                     | Input                    | Output                             | Result         |
| ----------------------------------------------------------------------------------------------- | ------------------------ | ---------------------------------- | -------------- |
| The user should be able to navigate to and from the Signup screen by means of a sign up button. | Click the sign up button | User is taken to the Signup screen | **Success** âœ… |

**Evidence:**

<div align="center">
  <img src="./src/signuplink.gif" alt="Clicking Sign Up Link">
</div>

##### Test 3: Validation/ sanitation of input

| Description                                                                                                                                       | Input                                                                                                                                 | Output                                                                                                                                                                            | Result         |
| ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- |
| The user must enter valid login data to be accepted (`email` must contain an `@` and a proceeding `.`, and password must be â‰¥ 8 characters long). | An email not containing and `@` or a `.`, first without and then with a password < 8 characters long and then one â‰¥ 8 characters long | Only when the credentials are entered in the format specified in the Description should the user be navigated to the Home screen, otherwise an appropriate error should be thrown | **Success** âœ… |

**Evidence:**

<div align="center">
  <img src="./src/testLogin2.gif" alt="Entry Field Validation">
</div>

### Signup

> _Additionally, if the user doesn't have an account, they can follow the `Sign Up` button to be taken to the [Signup Screen](https://github.com/samcalthrop/NodePad/tree/main/src/renderer/src/screens/SignUpScreen)_

In order to navigate to the Signup Screen, I used React's `useNavigate()` hook again in the Login Screen, this time to navigate to the Signup Page route:

```tsx
<Button variant="transparent" className={classes.button} onClick={() => navigate('/signup')}>
  Sign Up
</Button>
```

The Signup screen is a close copy of the login screen with a few differences; therefore the code (_for the frontend at least_) looks very similar for the most part.

The key differences are that there is a password re-entry field and the user's username is not asked for as a form of validation, but the overall structure of the code is very close to that of the Login Screen:

```tsx
import classes from '../LoginScreen/LoginScreen.module.css';
import { Screen } from '../Screen';
import { useNavigate } from 'react-router-dom';
import { Button, Title, TextInput, Group, PasswordInput } from '@mantine/core';
import { useForm } from '@mantine/form';

export const SignUpScreen = (): JSX.Element => {
  const navigate = useNavigate();

  // defining the rules for the login form
  const form = useForm({
    mode: 'uncontrolled',
    initialValues: {
      email: '',
      password: '',
      reEnterPassword: '',
    },

    // in-browser validation of email entry
    validate: {
      email: (value) => (/^\S+@\S+$/.test(value) ? null : 'Invalid email'),
      password: (value) => (value.length >= 8 ? null : 'Invalid password'),
      reEnterPassword: (value) => (value ? null : 'Passwords must match'),
    },
  });

  return (
    <Screen>
      <div className={classes.root}>
        <br />
        <Title order={1}>Sign Up</Title>
        <br />
        <form onSubmit={form.onSubmit(() => navigate('/login'))}>
          {/* username field */}
          <TextInput
            withAsterisk
            label="Email"
            placeholder="your@email.com"
            key={form.key('email')}
            {...form.getInputProps('email')}
          />

          {/* password field */}
          <PasswordInput
            withAsterisk
            label="Password"
            description="ensure password length is at least 8 characters long"
            placeholder="password-123"
            key={form.key('password')}
            {...form.getInputProps('password')}
          />

          {/* re-enter password field */}
          <PasswordInput
            withAsterisk
            label="Re-enter Password"
            placeholder="password-123"
            key={form.key('re-renter-password')}
            {...form.getInputProps('re-renter-password')}
          />

          {/* form submission */}
          <Group justify="flex-begin" mt="md">
            <Button type="submit" onClick={() => navigate('/login')}>
              Submit
            </Button>
          </Group>
        </form>
      </div>
    </Screen>
  );
};
```

One of the stand-out differences between the two screens is the extra field for re-entering the chosen password, using:

```tsx
validate: {
  ...
  reEnterPassword: (value) => (value ? null : 'Passwords must match'),
},
```

Which just checks that the passwords are exactly identical to one another, granting a successful signup if, and only if, this criterion is met.

#### The result

The result looks like this:

<img src="./src/signup.png"/>

#### Testing

##### Test 4: Validation/ sanitation of input

| Description                                                                                                                                                                                                     | Input                                                                                                                                                                                                                                                                                       | Output                                                                                                                                                                                                        | Result                                                                                                                 |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| The user must enter valid signup data to be accepted as a new user (`email` must contain an `@` and a proceeding `.`, the password must be â‰¥ 8 characters long _and_ the two password fields must be identical) | An email not containing and `@` or a `.`, first without and then with a password < 8 characters long and then one â‰¥ 8 characters long, then keep the previous credentials in the fields and use first a password that doesn't match the first password, and then a password that does match | Only in the case that the entered details match the format specified in the Description should the used be signed up and navigated back the the Login screen, otherwise an appropriate error should be thrown | **Failure** âŒ - _currently, entering anything into the fields, or even nothing at all results in a successful signup_ |

**Evidence:**

<div align="center">
  <img src="./src/testSignup1.gif" alt="Entry Field Validation">
</div>

##### Test 5: Backwards navigation

| Description                                                                                                                  | Input                                                | Output                                     | Result                                                                                                                                                                                                                                                    |
| ---------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The user should be able to navigate back to the Login screen should they decide they don't want to sign up for a new account | Click the back arrow to navigate to the Login screen | User is navigated back to the Login screen | **Partial Success** ðŸŸ¨ - _there is no back button in place right now - however, since the validation doesn't work, pressing the submit button (or pressing `enter`) has the same effect. This clearly isn't a solution, however technically does the job_ |

**Evidence:**

No evidence is needed; the evidence for the validation/ sanitation test above demonstrates the 'workaround' of just pressing submit to navigate back to the Login screen.

### Sidebar

> _The Sidebar is where the filetree for the user-selected root directory is displayed, within which the user can navigate to and select the file they want to edit._

The structure in which I built the file tree was in a way such that the program:

- iterates through each file in `treeNodeData`,
- checks their file extension to determine the file icon displayed by the filename, and,
- renders each file/ folder, along with their corresponding icons.

Firstly, I wrote the code to determine the file icon to be displayed next to each file by checking their file extension:

`Sidebar.tsx`:

```tsx
function FileIcon({ name, isFolder, expanded }: FileIconProps): JSX.Element {
  if (name.endsWith('package.json')) {
    return <NpmIcon size={14} />;
  }

  if (name.endsWith('.md')) {
    return <IconBook size={14} />;
  }

  // returns an opened/ closed folder based on the boolean value `expanded`
  if (isFolder) {
    return expanded ? (
      <IconFolderOpen size={14} stroke={2.5} />
    ) : (
      <IconFolderClosed size={14} stroke={2.5} />
    );
  }

  return <></>;
}
```

Then, I wrote the function `Leaf` to package the filename and file icon into a single `<div/>` element (as well as handling the event that the file is selected and navigating to the text editor using the `useNavigate()` hook), which allows each item to be iterated through and subsequently rendered:

`Sidebar.tsx`:

```tsx
function Leaf({
  node,
  expanded,
  hasChildren,
  elementProps,
  tree,
}: RenderTreeNodePayload): ReactElement<FileIconProps> {
  const navigate = useNavigate();

  return (
    <Group
      gap={5}
      {...elementProps}
      onClick={() => {
        tree.toggleSelected(node.value);
        tree.toggleExpanded(node.value);
        if (!node.children) {
          console.log('Sidebar: node selected: ', node);
          // navigate to the text editor
          navigate('/home/edit-node-meta');
        }
      }}
    >
      <div className={classes.leaf}>
        <FileIcon name={node.value} isFolder={hasChildren} expanded={expanded} />
        <Text className={classes.leafText}>{node.label}</Text>
      </div>
    </Group>
  );
}
```

And finally, assembling the tree requires the use of the `<Tree/>` element in the `<Sidebar/>` component:

`Sidebar.tsx`:

```tsx
export const Sidebar = (): JSX.Element => {
  return (
    <div className={classes.root}>
      <div className={classes.titleDiv}>
        <Title className={classes.title} order={1}>
          Sidebar
        </Title>
      </div>
      <Divider className={classes.divider} size="sm" />
      <div className={classes.filetreeDiv}>
        <Tree
          levelOffset="lg"
          className={classes.tree}
          selectOnClick
          data={treeNodeData}
          renderNode={(payload) => <Leaf {...payload} />}
        />
      </div>
    </div>
  );
};
```

The aim of the Sidebar is to render the user-selected files in a file tree - this requires the frontend to query the backend for these files, and return them in a suitable format to be rendered. Given that this would require code be written in at least 4 different files (`Sidebar.tsx`, `/types/index.ts`, `/preload/index.ts` and `/main/index.ts`), it would be very hard to write it all first, then track down any bugs that arise. To solve this issue, I decided it would be easier to find a way to make the separate components work in isolation - I used abstraction to break this down into front-end functionality, preload functionality, and backend functionality.

In order to verify that my code works in small steps, I decided to attempt to make the tree work first with hard-coded data on the frontend:

#### Step 1 - (Frontend) Rendering the tree using hard-coded data

Firstly, I used hard-coded `treeNodeData` below to verify that the tree would render correctly (this was the data Mantine used to demo the Tree element, which allowed me to directly compare between my version and theirs, meaning I could make sure the two were identical):

`Sidebar.tsx`:

```tsx
const treeNodeData: Array<TreeNodeData> = [
  {
    label: 'src',
    value: 'src',
    children: [
      {
        label: 'components',
        value: 'src/components',
        children: [
          { label: 'Accordion.tsx', value: 'src/components/Accordion.tsx' },
          { label: 'Tree.tsx', value: 'src/components/Tree.tsx' },
          { label: 'Button.tsx', value: 'src/components/Button.tsx' },
        ],
      },
    ],
  },
  ...{
    label: 'tsconfig.lib.json',
    value: 'tsconfig.lib.json',
  },
];
```

##### Verifying it works

To check that this code works, I booted up the app and checked the contents of the Sidebar:

<div align="center">
  <img src='./src/sidebarFrontend.gif' height="600" style="border-radius: 6px;"/>
</div>

This correctly displayed the hard-coded data, verifying the code written thus-far works as intended.

#### Step 2 - (Preload/ Main) Using hard-coded data

This next step required me to communicate data between the backend and the frontend - following [Electron's guide on backend-frontend communication](https://www.electronjs.org/docs/latest/tutorial/ipc) as described towards the start of the writeup, the communication of data requires a 'middleman' (_preload_) to handle/ secure the transport of data between `main` and `renderer`. This meant I had to define a function `getTreeNodeData()` as being a method on the inter-process communication API in `renderer`...

`types/index.ts`:

```ts
export type IpcAPI = {
  getTreeNodeData: GetTreeNodeData;
};
```

... define what the function does in `preload/index.ts` (_which passes a message on to the backend, and awaits the return of data which it then sends to the frontend_)...

`preload/index.ts`:

```ts
if (process.contextIsolated) {
  try {
    // communication between front and backend for data transfer (tree node data)
    // expose these functions to the backend (main):
    contextBridge.exposeInMainWorld('ipcAPI', {
      // retrieves file structure from given path, in TreeNodeData[] format
      getTreeNodeData: (path: string) => {
        ipcRenderer.send('get-tree-node-data', path);

        return new Promise((resolve) => {
          ipcRenderer.once('get-tree-node-data-success', (_event, data: Array<TreeNodeData>) =>
            resolve(data)
          );
        });
      },
    }
  }
}
```

... and tell the backend what should happen upon a message being received from `preload` telling it to retrieve the file tree from a given path with the message of 'get-tree-node-data' followed by the specific path - at this point, I used the same hard-coded data, only this time on the backend side so as to test that the data is correctly being sent from the backend to the frontend and rendered in the Sidebar:

`main/index.ts`:

```ts
...
app.whenReady().then(() => {
  ...
  // when the frontend requests the file tree...
  ipcMain.on('get-tree-node-data', (event: IpcMainEvent, path: string) => {
    // all files/ directories found and returned to frontend
    const data: Array<TreeNodeData> = [
      {
        label: 'src',
        value: 'src',
        children: [
          {
            ...
          },
        ],
        ...
      },
    ];
    event.sender.send('get-tree-node-data-success', data);
    console.log('tree node data successfully retrieved');
  });
}
```

Then I made use of React's `useState` and `useEffect` components to _retrieve_ and then _set_ `treeNodeData` dynamically as the returned object of type `TreeNodeData` by calling the `getTreeNodeData()` method on the Inter-Process Communication API (_note the distinction between `treeNodeData`, the variable containing the file tree structure, and `TreeNodeData`, the type provided by Mantine which is used to render the tree_):

`Sidebar.tsx`:

```tsx
export const Sidebar = (): JSX.Element => {
  const [treeNodeData, setTreeNodeData] = useState<Array<TreeNodeData>>([]);

  useEffect(() => {
    window.ipcAPI.getTreeNodeData().then((treeNodeData) => {
      setTreeNodeData(treeNodeData);
    });
  }, []);
  ...
};
```

##### Verifying it works

To check that this code works, I again ran up the app and checked the contents of the Sidebar:

<div align="center">
  <img src='./src/sidebarBackend.gif' height="600" style="border-radius: 6px;"/>
</div>

This correctly displayed the hard-coded data passed from the backend, verifying the code written thus-far works as intended.

#### Step 3 - (Main) Using data retrieved from user filesystem

Finally, since I knew that the tree renders correctly, and the communication between the frontend and backend are successful and correct, all I had to do was implement the functionality that **1)** retrieves the child folders and files recursively from the given directory, and, **2)** converts the data into a form the tree can use (convert it to the type `Array<TreeNodeData>`).

I created a new file, `getTreeNodeData.ts`, within the `main` directory. I then used this to create two functions to tackle each of the 2 criteria above (`convertDirectoryTree()` and `getTreeNodeData()`).

Firstly, `convertDirectoryTree()` recursively searches through the tree object passed in (`label` and `value` are assigned they're respective attributes, and children is assigned all the children the object has by use of recursion):

`getTreeNodeData.ts`:

```ts
import { TreeNodeData } from '@mantine/core';
import { DirectoryTree } from 'directory-tree';

// returns a given directory tree in the Array<TreeNodeData> form
export const convertDirectoryTree = ({ name, path, children }: DirectoryTree): TreeNodeData => ({
  label: name,
  value: path,
  children: children ? children.map(convertDirectoryTree) : undefined,
});
```

And then I created the `getTreeNodeData()` function, using the `directoryTree()` function provided by [the directory-tree package](https://www.npmjs.com/package/directory-tree) I found on [npmjs.com](https://npmjs.com) (_a website for package creators to post their open-source packages for public use_). This returns an object of type `DirectoryTree`. I used VSCode's click-through feature (`cmd`+`left-click` on a word/ phrase) to inspect the form this structure takes - this is what allowed me to extract useful data from the `DirectoryTree` object and return it as `TreeNodeData` in the `convertDirectoryTree()` function (_above_):

<img src='./src/clickThroughDirectoryTree.gif' />

As a result, I used the `convertDirectoryTree()` function on the object returned by the `directoryTree()` function call, which I then returned within square brackets `[]` to wrap the data in an array:

`getTreeNodeData.ts`:

```ts
...
import directoryTree from 'directory-tree';
...
// returns Array<TreeNodeData> from a given path
export const getTreeNodeData = (path: string): TreeNodeData[] => {
  const tree = directoryTree(path, { extensions: /\.(md|png|jpg|jpeg|gif)$/ });
  // debug log
  console.log(tree);

  return [convertDirectoryTree(tree)];
};
```

I used this function from `main/index.ts` by importing it with `import { getTreeNodeData } from './getTreeNodeData';`, and implemented it within the communication between the backend and frontend so as to return the actual file tree from the given path, rather than returning hard-coded data:

`main/index.ts`:

```ts
...
app.whenReady().then(() => {
  ...
  // when the frontend requests the file tree...
  ipcMain.on('get-tree-node-data', (event: IpcMainEvent, path: string) => {
    // all files/ directories found and returned to frontend
    const data: TreeNodeData[] = getTreeNodeData(path);
    event.sender.send('get-tree-node-data-success', data);
    console.log('tree node data successfully retrieved');
  });
  ...
})
```

##### Verifying it works

To test this works, I set the default directory to search be the root of this project and once more loaded the app and navigated to the home screen. To make sure the correct data was being both retrieved from the backend, and passed to the frontend from the backend, I logged the `treeNodeData` object both in `main` and renderer.

The console log on the backend looked as follows:

<img src='./src/backendLog.png' />

Which successfully showed the correct information. When comparing this to the console log on the frontend:

<img src='./src/frontendLog.png' height="600" style="border-radius: 6px;" />

We see that they match identically. Therefore, the retrieval of data and then communication of it has been verified to work completely

#### The result

The Sidebar screen on its own, without any content displayed beside it now looks like this:

<img src="./src/sidebar.png" />

#### Testing

##### Test 6: Tree is correctly rendered with icons + children

| Description                                                                                                                                                                                                                         | Input                                                                          | Output                                                                                                        | Result                                                                                                                    |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| The Sidebar correctly displays the contents of a given source directory, displays closed folders with a closed folder icon, displays open folders with an open folder icon, and displays markdown documents with an open book icon. | Open the app to the Home screen, and observe the data displayed in the Sidebar | The files/ folders in the Sidebar should be identical to the files in the user's filesystem at that directory | **Partial Success** ðŸŸ¨ - _markdown icons are rendering correctly, but folder icons only render for folders with children_ |

**Evidence:**

<div align='center'>
  <img src='./src/testSidebar1.png' />
</div>

##### Test 7: Folders can be clicked on, opened, and closed

| Description                                                                                                                                                                                     | Input                                                                      | Output                                                                                                                | Result         |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | -------------- |
| When leaves of the tree are clicked on: if the leaf is a folder, the leaf should be expanded and its children shown indented below it, with the closed folder icon becoming an open folder icon | Left click on folders in the Sidebar, first to open and then to close them | Folders should expand and display child contents upon the first click, and retract the children upon the second click | **Success** âœ… |

**Evidence:**

<div align='center'>
  <img src='./src/sidebarBackendDataRetrieval.gif' height="600" style="border-radius: 6px;"/>
</div>

##### Test 8: Markdown files can be opened by clicking

| Description                                                                                                                    | Input                                         | Output                                                        | Result                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| When leaves of the tree are clicked on: if the leaf is a markdown file, the user should be navigated to the text editor screen | Left click on any of the files in the Sidebar | The user is navigated to the Text Editor (_'Edit Node Meta'_) | **Success** âœ… - _the contents of the file are not displayed, though this is an issue to be addressed/ tested for when I build up the text editor_ |

**Evidence:**

<div align='center'>
  <img src='./src/testSidebar3.gif'/>
</div>

##### Test 9: Sidebar contents are consistent

| Description                                                                                                                                                                                                                                                       | Input                                                                                                                                                                                                                         | Output                                                                  | Result                                                                                                                                                     |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| When a markdown file is clicked on, this causes the text editor to be opened - when this happens, the Sidebar's state must remain _i.e if one or several folders is/ are open, they should stay open even when the user navigates to a different part of the app_ | Navigate between the Home screen and the Text Editor, _e.g by clicking on a file in the Sidebar, and then exiting back to the Home screen_, making sure the Sidebar is not in its original state (_open a few folders first_) | Sidebar should retain the state of having these folders open throughout | **Failure** âŒ - _when the user is navigated to the text editor, the file tree is reset, even taking a second or two to re-retrieve and load its contents_ |

**Evidence:**

<div align='center'>
  <img src='./src/testSidebar4.gif' height="600" style="border-radius: 6px;" />
</div>

##### Test 10: Filetree sits in the Sidebar without affecting other components

| Description                                                                             | Input                 | Output                                        | Result                                                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------- | --------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| When the filetree is collapsed/ expanded, the Sidebar's size/ styling should not change | Resize the app window | Ensure the criteria in the Description is met | **Failure** âŒ - _the Sidebar becomes more elongated when files are expanded, even going off the page sometimes, and the original size is achieved by collapsing these folders - the Sidebar should remain a consistent size_ |

**Evidence:**

<div align='center'>
  <img src='./src/testSidebar5.gif' />
</div>

### Home

> _The Home Screen is where all markdown files in the user-selected root directory will be displayed visually in a network_

Home only consists of a few basic components currently:

`HomeScreen.tsx`:

```tsx
<Title order={1}>Home</Title>
<Canvas drawFunc={drawPulsingDot} width={200} height={200} />
<Text>Edit node meta</Text>
<Button
  variant="subtle"
  className={classes.button}
  onClick={() => navigate('/edit-node-meta')}
>
  Ok
</Button>
```

The two most important parts are he `<Button/>` and `<Canvas/>` elements - the button is the source of navigation, again using the `navigate()` function to transport the user to the editing screen (currently named `edit-node-meta` - this may change to something more user friendly) which will become valuable when combined with the other key element - `<Canvas/>`:

```tsx
<Canvas drawFunc={drawPulsingDot} width={200} height={200} />
```

This makes use of the draw function attribute, `drawFunc`, which takes in the `drawPulsingDot()` function I wrote quickly to get to grips with the basics of the canvas - this is imported at the top of the file from the path `@renderer/drawing/drawPulsingDot`. If we open `drawPulsingDot.ts`, we can see where the code for the 'node network' will go:

`NodeNetwork.tsx`

```tsx
export const drawPulsingDot: DrawFunc = (frameCount: number, context: CanvasRenderingContext2D) => {
  context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  context.fillStyle = 'var(--mantine-primary-color-filled)'; // doesn't work
  context.beginPath();
  context.arc(50, 100, 20 * Math.sin(frameCount * 0.05) ** 2, 0, 2 * Math.PI);
  context.fill();
};
```

Currently, all the function does is clear the canvas with the `clearRect()` method and draws a circle that grows/ shrinks based on the frame count _a.k.a time_ using the `arc()` method. This is just a prototype to test how canvas works as it's entirely new to me, and so I'm taking time to learn canvas separately.

Then I wrapped the code for the Home screen in the `<ScreenWithSidebar/>` element in order to have both the Home screen and sidebar displayed next to one another:

`HomeScreen.tsx`:

```tsx
<ScreenWithSidebar>
  ...
  <Title order={1}>Home</Title>
  <Canvas drawFunc={drawPulsingDot} width={200} height={200} />
  <Text>Edit node meta</Text>
  <Button variant="subtle" className={classes.button} onClick={() => navigate('/edit-node-meta')}>
    Ok
  </Button>
  ...
</ScreenWithSidebar>
```

Where `<ScreenWithSidebar/>` is an just a `<Sidebar/>` element wrapped within a `<Screen/>` element with desired styling applied:

`screenWithSidebar.tsx`:

```tsx
export const ScreenWithSidebar = ({ children }: ScreenWithSidebarProps): JSX.Element => {
  return (
    <Screen>
      <div className={classes.root}>
        <div className={classes.sidebar}>
          <Sidebar />
        </div>
        <div>{children}</div>
      </div>
    </Screen>
  );
};
```

Lastly the use of `children` wrapped within a `<div/>` element in this function...

```tsx
export const ScreenWithSidebar = ({ children }: ScreenWithSidebarProps): JSX.Element => {
  ...
  <div>{children}</div>
};
```

... allows any elements to be placed within this element within a `<div>`.

#### The result

The result of this code is:

<img src="./src/home.png"/>

#### Testing

Nothing worth testing has yet been implemented in the Home screen, so there isn't anything to test here.

### Text Editor

> _The Text Editor is where the user is taken to edit the text of the selected markdown_

The code for the text editor screen is as follows:

`EditNodeMetaScreen.tsx`:

```tsx
import classes from './EditNodeMetaScreen.module.css';
import { ScreenWithSidebar } from '../ScreenWithSidebar';
import { useNavigate } from 'react-router-dom';
import { Button, Title } from '@mantine/core';
import { MDXEditor, MDXEditorMethods, codeBlockPlugin, headingsPlugin } from '@mdxeditor/editor';
import '@mdxeditor/editor/style.css';
import { useEffect, useRef, useState } from 'react';

export const EditNodeMetaScreen = (): JSX.Element => {
  const navigate = useNavigate();
  // uses a react state to get/ change the current contents of the file being edited
  const mdxEditorRef = useRef<MDXEditorMethods>(null);
  // hard-coded path to the README in order to retrieve test data from the backend
  const path = './';

  // test
  const [fileContents, setFileContents] = useState<string>();
  // retrieving the file contents from the backend
  useEffect(() => {
    window.ipcAPI.getFileContents(path).then((fileContents) => {
      setFileContents(fileContents);
    });
  }, []);

  return (
    <ScreenWithSidebar>
      <div className={classes.root}>
        <div className={classes.thing}>
          <Title order={2}>Edit node meta</Title>

          {/* a class specially for the markdown editor instance, as specified in the documentation for MDXEditor: https://mdxeditor.dev/editor/docs/theming */}
          <div className={classes.mdxeditor}>
            <MDXEditor
              ref={mdxEditorRef}
              className="dark-theme dark-editor"
              markdown={fileContents ?? '# Failed to retrieve contents'}
              plugins={[codeBlockPlugin(), headingsPlugin()]}
            />
          </div>

          <Button variant="subtle" className={classes.button} onClick={() => navigate('/home')}>
            Exit
          </Button>
        </div>
      </div>
    </ScreenWithSidebar>
  );
};
```

In order to retrieve the contents of a specified file, the React hooks `useState` and `useEffect` have to be used in order to get past the asynchronous nature of the communication and transferral of data between the back and frontend:

`EditNodeMetaScreen.tsx`:

```tsx
const [fileContents, setFileContents] = useState<string>();
useEffect(() => {
  window.ipcAPI.getFileContents(path).then((fileContents) => {
    setFileContents(fileContents);
  });
}, []);
```

I followed up by using the same pattern as used previously for Electron's Inter Process Communication, defining the method on the `IpcAPI` interface in `types/index.ts`:

`types/index.ts`:

```ts
...
export type IpcAPI = {
  ...
  getFileContents: (path: string) => Promise<string>;
  ...
};
```

Which I then described in `preload/index.ts`, which sends a message to `main` to tell it to return the contents from a given file, and then awaits the returned message:

`preload/index.ts`:

```ts
...
if (process.contextIsolated) {
  try {
    ...
    contextBridge.exposeInMainWorld('ipcAPI', {
      ...
      // communication between front and backend for data transfer (contents of selected file)
      getFileContents: (path: string) => {
        ipcRenderer.send('get-file-contents', path);

        return new Promise((resolve) => {
          ipcRenderer.on('get-file-contents-success', (_event, fileContents: string) => {
            console.log('on get-file-contents-success: fileContents:', fileContents);
            resolve(fileContents);
          });
        });
      },
      ...
    }
    ...
  }
}
```

Before finally defining on the backend, creating a new file, `fileHandling.ts`, to handle all file manipulation. In this file I created the `getFileContents()` function, which uses the `fs` package (again found on [npmjs.com](http://npmjs.com)) to extract the text from a given file, returning the contents and/ or an appropriate error message:

`fileHandling.ts`:

```ts
...
import fs from 'node:fs';

export const getFileContents = (filePath: string): string => {
  try {
    const fileContents = fs.readFileSync(filePath, 'utf8');
    console.log('getFileContents', { fileContents });
    return fileContents;
  } catch (error) {
    console.error('Error reading file:', filePath, error);
    throw error;
  }
};
```

Which I used in `main` to handle the request from `preload` and return the contents of the filepath given:

`main/index.ts`:

```ts
import getFileContents from './fileHandling';
...
app.whenReady().then(() => {
  ...
  // when ipcMain receives request for file contents...
  ipcMain.on('get-file-contents', (event: IpcMainEvent, path: string) => {
    // file contents are read in and returned
    const fileContents: string = getFileContents(path);
    console.log('on get-file-contents: fileContents:', fileContents);
    event.sender.send('get-file-contents-success', fileContents);
  });
  ...
})
```

Most of the other code is self-explanatory, or already explained by previous analysis, leaving the `<MDXEditor>` element as the only unfamiliar section:

`EditNodeMetaScreen.tsx`:

```tsx
<MDXEditor markdown={fileContents ? fileContents : ''} plugins={[headingsPlugin()]} />
```

Using the ternary operator `fileContents ? fileContents : ''` allows for the potentiality that the value returned by `getFileContents()` could be `null`, meaning that the empty quote marks, `''` would be rendered in the case that the retrieval of `fileContents` fails. Additionally, the `plugins` attribute specifies any plugins the editor should use. In this case, only the `headingsPlugin` is used, meaning only markdown headings will be rendered.

#### The Error

After writing this code and running the program, I got came across an issue: the use of `MDXEditor` is causing errors due to security rules put in place by electron, resulting in an empty screen being displayed - I knew that if I couldn't find a fix for this issue, I'd have to find a new library or attempt a home-made parser and renderer:

<img src="./src/editnodemetaerror.png"/>

The contents of the dev tools console output when run is:

<img src="./src/editnodemetadevtools.png"/>

Tracing this bug we can see the Content Security Policy for this project does not allow the `eval` function to be called. This error leads back to:

```
at eval (<anonymous>)
at getGlobal (@mdxeditor_editor.js?v=e8b0c740:64659:10)
at @mdxeditor_editor.js?v=e8b0c740:64660:2
```

within the `@mdxeditor_editor.js?v=e8b0c740:64660:2` file - _a.k.a. the error is within the MDXEditor module, which I can't edit_. The exact source of the error is found to be within this function, which I tracked down in the MDXEditor module, but additionally found mentioned briefly in issues raised on Stack Overflow:

```js
var GLOBAL = (function getGlobal() {
  var savedEval = eval;
  return savedEval('this');
})();
```

#### How to fix it

One potential solution to this issue is to try and change the Content Security Policy (CSP) and make it less strict, or find a way to allow the script to run. The Content Security Policy definition is in `./src/renderer/src/index.html`, within a `<meta/>` tag:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
/>
```

After inspecting [Electron's online documentation](https://www.electronjs.org/docs/latest/), I found the following information to be potentially useful:

"The following CSP will allow Electron to execute scripts from the current website and from apis.example.com.":

```
// Bad
Content-Security-Policy: '*'

// Good
Content-Security-Policy: script-src 'self' https://apis.example.com
```

Applying this to how I've written my code, I changed the `<meta>` tag on my app's Content Safety Policy from:

`renderer/index.html`:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
/>
```

to:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://github.com/mdx-editor/editor; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
/>
```

allowing unsafe scripts to be run from specified sources (_in this case, potentially unsafe scripts can be run from the <MDXEditor> source code - https://github.com/mdx-editor/editor_).

#### The result

After successfully debugging the issue, the editor looks like this (I highlighted the background in red to make the content area more visible):

<img src="./src/editnodemetarendererror.png"/>

**NOTE:** _though this solves the issue of the CSP, the editor is still not rendering the text it should - the contents of the `README.md` file in the root directory. This is an issue I have not yet been able to work out how to solve, but I aim to have it solved in Iteration 2._

#### Testing

##### Test 11: Check the correct file contents are retrieved from the backend

| Description                                                                                                 | Input                            | Output                                                            | Result         |
| ----------------------------------------------------------------------------------------------------------- | -------------------------------- | ----------------------------------------------------------------- | -------------- |
| Check that the file clicked on in the Sidebar has the correct contents retrieved from the user's filesystem | Left click a file in the Sidebar | The console on the backend should have the contents printed to it | **Success** âœ… |

**Evidence:**

(_the contents of the file clicked on are logged to the backend console_)

<div align='center'>
  <img src='./src/backendretrieval.png' />
</div>

##### Test 12: Check that the contents are correctly displayed on the frontend

| Description                                                                                                              | Input                            | Output                                                                                                            | Result                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------ | -------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| Check that the same contents retrieved from the user's filesystem are then displayed on the frontend, in the text editor | Left click a file in the Sidebar | User is navigated to the Text Editor, and the contents of the file are retrieved and displayed in the Text Editor | **Failure** âŒ - _the contents are failing to load, resulting in the 'Failed to retrieve contents' being displayed_ |

**Evidence:**

<div align='center'>
  <img src='src/rendererror.png'/>
</div>

##### Test 13: Check that the text is rendered as markdown

| Description                                                                                                           | Input                            | Output                                                                                                                         | Result         |
| --------------------------------------------------------------------------------------------------------------------- | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | -------------- |
| Test that whatever content is displayed in the text area within the text editor is rendered using markdown formatting | Left click a file in the Sidebar | User is navigated to the Text Editor, and the contents of the file are retrieved and _rendered as markdown_ in the Text Editor | **Success** âœ… |

**Evidence:**

<div align='center'>
  <img src='./src/testTextRendering.gif' />
</div>

### Testing the app as a whole

#### Test 14: Test how each part of the app scales when resizing the window

Each of the following tests is tto see how each component in the app responds to window resizing:

##### Test 14a: Login screen resizing

| Description                                                                                                                                                                                           | Input                                               | Output                                           | Result                                                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| The central login card should stay a fixed width in the centre of the page, unless the width or height is less than the width or height of the card. In this case, the card should shrink accordingly | Resize the app window when viewing the Login screen | Criteria laid out in the Description must be met | **Partial Success** ðŸŸ¨ - _components are resizing well, but should have a maximum fixed width_ |

**Evidence:**

<div align='center'>
  <img src='./src/testLoginResize.gif' />
</div>

##### Test 14b: Signup screen resizing

| Description                                                                                                                                                                                            | Input                                                | Output                                           | Result                                                                                         |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| The central signup card should stay a fixed width in the centre of the page, unless the width or height is less than the width or height of the card. In this case, the card should shrink accordingly | Resize the app window when viewing the Signup screen | Criteria laid out in the Description must be met | **Partial Success** ðŸŸ¨ - _components are resizing well, but should have a maximum fixed width_ |

**Evidence:**

<div align='center'>
  <img src='./src/testSignupResize.gif' />
</div>

##### Test 14c: Sidebar screen resizing

| Description                                                                                                                                                                                                            | Input                                                                                   | Output                                           | Result                                                                                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The sidebar should stay a on the left side of the screen with a margin from the top, bottom, and left of the screen. If the height of the screen shrinks, it should do the same in order to maintain the margin indent | Resize the app window when viewing the Sidebar (part of the Home screen or Text Editor) | Criteria laid out in the Description must be met | **Partial Success** ðŸŸ¨ - _the Sidebar's height is independent of the height of the screen, and shrinking just causes the content to go off the bottom of the page. However, it retains margins to the left and top, and its width stays fixed_ |

**Evidence:**

<div align='center'>
  <img src='./src/testHomeResize.gif' />
</div>

##### Test 14d: Home screen resizing

| Description                                                                                                                                                                                             | Input                                              | Output                                           | Result         |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------ | -------------- |
| The content of the Home screen should fit within the remaining area of the screen (the area not taken up by the Sidebar), and text should remain a constant width regardless of the width of the screen | Resize the app window when viewing the Home screen | Criteria laid out in the Description must be met | **Success** âœ… |

**Evidence:**

This can be seen when resizing the Sidebar, so the evidence for the test above (_14d_) can also be used as evidence for this test.

##### Test 14e: Text Editor screen resizing

| Description                                                                                                                                           | Input                                                     | Output                                           | Result         |
| ----------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------ | -------------- |
| The content of the text editor should shrink to a minimum width, and the text should overflow off the screen if its height exceeds that of the screen | Resize the app window when viewing the Text Editor screen | Criteria laid out in the Description must be met | **Success** âœ… |

**Evidence:**

<div align='center'>
  <img src='./src/testResizeText.gif' />
</div>

#### Test 15: Colour scheme is consistent throughout the app

| Description                                                                                                        | Input                                   | Output                                                                                   | Result                                                                                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------ | --------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test that the colours used for each screen in the app make sense, and are consistent _i.e. 'all buttons are blue'_ | Navigate through all screens in the app | Colours of components should be consistent and deliberate, as set out in the Description | **Partial Success** ðŸŸ¨ - _component colours are consistent, however there are come colours that don't fit the scheme, for example the folder icons are orange, and no other part of the app is in any way similar_ |

**Evidence:**

<div align='center'>
  <img src='./src/userflow.gif' />
</div>

See next: [Stakeholder Feedback](2.1.4-stakeholder_feedback.md)
