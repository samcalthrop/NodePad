# 2.3.3 - Annotation of Code

> _an overview & explanation of the code written to build this project - **this includes testing**_

## Toolbar

### Implementing Settings

- first step was to create button on sidebar that triggers the opening of a mantine modal UI component

<img src="./src/settings1.png"/>

- then set up the button to trigger a mantine modal UI component to open upon being clicked. Also made basic layout, including navbar on left

<img src="./src/settings3.png"/>

- then make each item in the navbar open their respective pages, and started adding filler content to see how it would appear, and give client an idea of how it looks

<img src="./src/settings2.png"/>

- then added functionality to the `select directory` button, linking to backend (main) via preload and allowing the user's native file explorer to open, allowing them to select a root directory for its path then to be displayed just above the button:

<img src="./src/settingsdirectory.gif"/>

making changes from the original design specification:

varying icon:
<img src="./src/settings5.png"/>

```tsx
<IconRightArrow />
```

and

```tsx
<IconCornerDownLeft />
```

and

```tsx
<IconCheck />
```

varying position:
<img src="./src/settings6.png"/>

```tsx
<Flex gap="sm" justify="center" align="center" direction="row" wrap="wrap">
```

to

<img src="./src/settings7.png"/>

```tsx
<Flex gap="sm" justify="flex-start" align="center" direction="row" wrap="wrap">
```

to

<img src="./src/settings8.png"/>

```tsx
<Flex gap="sm" justify="flex-end" align="center" direction="row" wrap="wrap">
```

- last one works well if I want the profile picture to go to left of credentials - UPDATE DESIGN PART 1

- then I added a profile picture selection to the account section, with a default 'user' image if none picked by the user. the image is selected by clicking on the profile picture circle, and navigating through the user's filesystem:

<img src="./src/settings9.png"/>

- how it looks with a demo image selected

<img src="./src/settings10.png"/>

demo:

<img src="./src/settingsimage.gif"/>

discovered new syntax for styling mantine components, rather than hacking it with dev tools + `!important`:

```tsx
<NativeSelect
  classNames={{
    section: classes.nsSection,
    input: classes.nsInput,
    wrapper: classes.nsWrapper,
  }}
  ...
/>
```

#### Using a provider to share selected directory

- with sidebar
- with node network

### Adding a Home Button

## Overhauling the UI Hierarchy

### Home Hierarchy

<img src="./src/hierarchyhome.png"/>

### Text Editor Hierarchy

<img src="./src/hierarchytexteditor.png"/>

### Settings Hierarchy

<img src="./src/hierarchysettings.png"/>

restructuring using <Modal.Root /> etc for control over components.

## Improving Aesthetics

### Scrollbars

### Manual Dynamic Resizeable Sidebar

#### 'Jumping' Error

When resizing the sidebar from a width not equal to the initialised width, the sidebar jumped back to the initial width before resizing:

<img src="./src/resizeJump.gif" />
The code was:

```ts
const [sidebarWidth, setSidebarWidth] = useState(300);
const [resizing, setResizing] = useState(false);
const minWidth = 250;
const maxWidth = 450;

// function allowing the manual dynamic resizing of the sideba
const startResizing = useCallback((mouseDownEvent: React.MouseEvent) => {
  setResizing(true);
  const startX = mouseDownEvent.clientX;
  const startWidth = sidebarWidth;

  const startResizing = (mouseMoveEvent: MouseEvent): void => {
    const difference = mouseMoveEvent.clientX - startX;
    const newWidth = startWidth + difference;
    if (newWidth > minWidth && newWidth < maxWidth) {
      setSidebarWidth(newWidth);
    }
  };

  const stopResizing = (): void => {
    setResizing(false);
    window.removeEventListener('mousemove', startResizing);
    window.removeEventListener('mouseup', stopResizing);
  };

  window.addEventListener('mousemove', startResizing);
  window.addEventListener('mouseup', stopResizing);
}, []);
```

The solution:

<img src="./src/noResizeJump.gif" />

The code:

```ts
const [sidebarWidth, setSidebarWidth] = useState(300);
const [resizing, setResizing] = useState(false);
const minWidth = 250;
const maxWidth = 450;

// function allowing the manual dynamic resizing of the sideba
const startResizing = useCallback(
  (mouseDownEvent: React.MouseEvent) => {
    setResizing(true);
    const startX = mouseDownEvent.clientX;
    const startWidth = sidebarWidth;

    const startResizing = (mouseMoveEvent: MouseEvent): void => {
      const difference = mouseMoveEvent.clientX - startX;
      const newWidth = startWidth + difference;
      if (newWidth > minWidth && newWidth < maxWidth) {
        setSidebarWidth(newWidth);
      }
    };

    const stopResizing = (): void => {
      setResizing(false);
      window.removeEventListener('mousemove', startResizing);
      window.removeEventListener('mouseup', stopResizing);
    };

    window.addEventListener('mousemove', startResizing);
    window.addEventListener('mouseup', stopResizing);
  },
  [sidebarWidth]
);
```

### Removing/ Making Custom Title Bar

### Login/ Signup Design

### Text Editor

- used debugging techniques such as the dev tools (`fn`+`f12`) to isolate each div to work out where to apply the styling changes I wanted.

[insert image and gif here]

- process repeated for each change

## Network Revisions & Improvements

- note that NodeNetwork function is bulky and should be modularised/ broken down

### Adding View & Edit Modes

use draw function code, talk about several code blocks depending on the mode

redrawing dependant on updating the mode:

```ts
const draw = useCallback(() => {
  ...
}, [nodes, connections, draggingConnection, radius]);
```

to:

```ts
const draw = useCallback(() => {
  ...
}, [nodes, connections, draggingConnection, radius, mode]);
```

### Adding More Functionality to Nodes

- (view mode) right clicking opens node
- (edit mode) left clicking drags node around
- (edit mode) right clicking drags connection

## Implementing an SQLite Database

- take screenshots of ui + code

See next: [Stakeholder Feedback](2.3.6-stakeholder_feedback.md)

## Text Editor - Adding Saving

### File Content Saving

mdxEditor docs very sparse, not providing examples of usage, so I had to look into 'throttling' again (I needed this when optimising the network as well, through the use case was too different to be ble to just cross reference).

<img src="./src/mdxEditorNotHelpful.png"/>

After not much success, I made use of chatGPT to ask about how to apply the concept of 'throttling' to this problem:

<img src="./src/aiThrottlingHelp.png"/>

### File Name Saving

used similar concept, only working with a `<div/>` instead of `<MDXEditor/>`, and modifying the save times to be every time the user presses `enter`, rather than every 2000ms. Got backend functionality working with some difficulty, but issue arising when trying to open a renamed file:

<img src='./src/renameTitleOnClickError.png'>

(error occurred when clicking on the `checklist wha.md` file, which I had just renamed). After considering where the error could have arisen, I found it most likely that the culprit was in the sidebar - the filetree only updates when the root directory is changed as seen in the `useCallback()` function:

```tsx
useEffect(() => {
  if (rootDirPath) {
    window.ipcAPI.getTreeNodeData(rootDirPath).then((treeNodeData) => {
      setTreeNodeData(treeNodeData);
    });
  }
}, [rootDirPath]);
```

where the argument passed at the end of the function, `[rootDirPath]`, means the function is called if and only if the root directory is changed. This is an issue as it means any files that have their names changed won't necessarily have their names changed in the filetree - the architecture of the communication between front and back end for retrieval of file contents then means that these incorrect names can be send to the backend for content retrieval, resulting in a behaviour such that a file can be renamed once, but subsequent renamings result in error:

<img src="./src/callstack.png">

Therefore, I need to modify the callback such that the correct file names are retrieved upon any of the titles of files/ folders being changed, so the program doesn't take the wrong filename and send it to the backend to return its contents. This means updating the callback to depend on `title` as well as `rootDirPath` _i.e it will be called every time there is a change to either of those variables_:

```tsx
useEffect(() => {
  if (rootDirPath) {
    window.ipcAPI.getTreeNodeData(rootDirPath).then((treeNodeData) => {
      setTreeNodeData(treeNodeData);
    });
  }
}, [rootDirPath, title]);
```

However, since the Sidebar relies on `TreeNodeData` and thus `selectedTreeNodeData`, `selectedTreeNodeData` must also be updated with the new title - if not, the title will update, but when clicking on the renamed file in the file tree, its title will still be the original title. As a result, it will request the backend to access a file that no longer exists, as it's under a new name. This lead to me adding the following to the `handleSaveTitle` function:

```tsx
const handleSaveTitle = useCallback(
  ...
    setSelectedTreeNodeData({
      ...selectedTreeNodeData,
      value: result.path,
      label: newTitle,
    });
  [selectedTreeNodeData, setTitle, setSelectedTreeNodeData]
);
```

Upon implementing this change, I found an error was getting raised every time I renamed a file:

<img src=[gif goes here]>

Given that this happened _every time_ a new name was submitted, this had to mean that the issue was within `handleSaveTitle()`. Given that the error suggested the backend was trying to open a file named 'undefined', the data being passed from the front-end - `selectedTreeNodeData` - was also undefined. This suggested that functions were being called out of sync:

1. The file is renamed
2. `setSelectedTreeNodeData()` is called, setting value to `result.path` **before** `renameFile()` is completely executed _(the await keyword tells us it has an asynchronous response time)_
3. `renameFile()` returns result

<img src="./src/asynchronousError.png" />

Where the sequence should be:

1. The file is renamed
2. `renameFile()` returns result
3. `setSelectedTreeNodeData()` is called, setting value to `result.path`

<img src="./src/asynchronousFixed.png" />

To fix this, a new asynchronous `Promise` is called to wait one tick before continuing execution. This allows enough time for the backend to write the changes to the filename and return a result:

```tsx
await new Promise((resolve) => setTimeout(resolve, 0));
```

The result of these fixes on `handleSaveTitle()` is:

```tsx
const handleSaveTitle = useCallback(
  async (newTitle: string): Promise<void> => {
    if (!selectedTreeNodeData) return;
    try {
      const result = await window.ipcAPI.renameFile(selectedTreeNodeData.value, newTitle);
      // update the title
      setTitle(newTitle);
      // wait one tick to ensure file system operation is complete...
      await new Promise((resolve) => setTimeout(resolve, 0));
      // ...before updating the tree node data to prevent operations occurring out of sync
      setSelectedTreeNodeData({
        ...selectedTreeNodeData,
        value: result.path,
        label: newTitle,
      });
    } catch (error) {
      console.error('Error renaming file:', error);
    }
  },
  [selectedTreeNodeData, setTitle, setSelectedTreeNodeData]
);
```

This led me to think about the way nodes are rendered in the Network as well, as the nodes are rendered in a similar fashion
