# 2.3.3 - Annotation of Code

> _an overview & explanation of the code written to build this project - **this includes testing**_

For Iteration 3, my goals were to make progress in the following areas:

- [Toolbar](#toolbar)
  - [Settings Button](#implementing-settings)
    - [Appearance](#appearance)
    - [Account](#account)
    - [Files](#files)
    - [Help](#help)
  - [Home Button](#home-button)
- [Overhauling the UI Hierarchy](#overhauling-the-ui-hierarchy)
- [Network](#network-revisions--improvements)
  - [View & Edit Modes](#adding-view--edit-modes)
  - [More Functionality for Nodes](#adding-more-functionality-to-nodes)
  - [Network Physics](#physics)
    - [Collisions](#collisions)
    - [Boid's Algorithm](#boids-algorithm)
- [Text Editor - Saving](#text-editor---adding-saving)
  - [File Content Saving](#file-content-saving)
  - [Title Renaming](#file-name-saving)
- [Implementing a Database](#implementing-an-sqlite-database)
  - [Login & Signup](#login--signup)
  - [Account Customisation](#account-customisation)

## Toolbar

The Toolbar occupies a space at the bottom of the Sidebar, below the Filetree - this will house several buttons, all of which were set out in the [initial plan](../../1%20-%20Analysis/1.5-proposed_solution_features.md#sidebar), and then more specifically planned in the hierarchy chart [first iteration](../2.1-Iteration1/2.1.2-functionality_of_prototype.md):

- [Home button](/2%20-%20Iterative%20Development/2.3-Iteration3/2.3.3-annotation_of_code.md#home-button) - A link that will transport the user back the home view (where the Network is) upon being clicked
- [Settings](/2%20-%20Iterative%20Development/2.3-Iteration3/2.3.3-annotation_of_code.md#implementing-settings) - A button that activates a pop-up window where the user can modify certain aspects of the app/ experience, for example by picking a theme, or changing their username
- New file - A button that creates a new file upon being clicked
- New folder - A button that creates a new directory

### Implementing Settings

My first port of call this iteration was to create an easily accessible settings page, indicated by a cog icon in the Toolbar - this will host many important features of the app, one of which being the user's ability to select the source directory within which their notes will be stored. This is an integral part of the app, and so was high on my priority list

1. The first step was to create button in the sidebar, within the newly created Toolbar `<div/>` that triggers the opening of a [mantine modal UI component](https://mantine.dev/core/modal/) - a component I found after looking into Mantine's documentation that exhibits the 'pop-over' effect that I was looking for.

In order to modularise the code base, I created a separate file for the Settings page...

`../components/SettingsModal/SettingsModal.tsx`:

```tsx
export const SettingsModal = (): JSX.Element => {
  // react state used to globally keep track of if settings is open
  const [opened, { open, close }] = useDisclosure(false);

  return (
    <>
      <!-- the skeleton of the pop-over page -->
      <Modal.Root
        className={classes.modal}
        opened={opened}
        onClose={close}
        centered
        styles={{
          title: {
            fontSize: '24px',
            fontWeight: 'normal',
          },
        }}
      >
        <!-- the behaviour of the background when settings is open -->
        <Modal.Overlay backgroundOpacity={0.2} blur={1.8} />
        <!-- the content to be displayed within the pop-over -->
        <Modal.Content radius="13px" className={classes.content}>
          <!-- the 'sidebar' where the menu of settings will be displayed -->
          <NavBar />
        </Modal.Content>
      </Modal.Root>

      <!-- the button that will appear in the toolbar -->
      <Button variant="default" onClick={open}>
        <IconSettings />
      </Button>
    </>
  );
};
```

... which I then imported into the Sidebar file for use...

`../components/Sidebar/Sidebar.tsx`:

```tsx
import { SettingsModal } from '../SettingsModal/SettingsModal';
...

<div className={classes.toolbar}>
  <SettingsModal />
</div>
```

... resulting in:

<img src="./src/settings1.png"/>

2. Then I defined the contents of the menu, or 'Navbar' as described in the code, adding the 4 main features I saw to be relevant in my plan:

- [Appearance](./2.3.3-annotation_of_code.md#appearance)
- [Account](./2.3.3-annotation_of_code.md#account)
- [Files](./2.3.3-annotation_of_code.md#files)
- Help

In order to modularise the code _within the file_, I created 4 separate functions, each returning their respective components as `JSX.Element` objects...

`SettingsModal.tsx`:

```tsx
// modularising each component of the Navbar
const Appearance = (): JSX.Element => {
  ...
}
const Account = (): JSX.Element => {
  ...
}
const Files = (): JSX.Element => {
  ...
}
const Help = (): JSX.Element => {
  ...
}
```

... which could then be used within the `Navbar` component, making use of [Mantine's `Tabs` component](https://mantine.dev/core/tabs/) to build the skeleton of the Navbar panel. Seeing how much code is already in the Navbar function's return object, it's clear that the modularisation I applied above was certainly necessary in cleaning up the file and making it more readable and easy to modify in future development...

`SettingsModal.tsx`:

```tsx
const NavBar = (): JSX.Element => {
  const [section, setSection] = useState<string>('appearance');

  return (
    <div className={classes.root}>
      <div className={classes.header}>
        <Title className={classes.title}>settings</Title>
        <Title className={classes.section}>{section}</Title>
        <Modal.CloseButton className={classes.close} size="xl" />
      </div>
      <div>
        <Divider />
      </div>
      <Tabs
        className={classes.tabs}
        color="var(--mantine-color-defaultScheme-2)"
        defaultValue="appearance"
        variant="pills"
        orientation="vertical"
        radius={0}
        onChange={(value) => setSection(value || 'appearance')}
      >
        {/* creating a sidebar panel ('navbar') */}
        <Tabs.List className={classes.navbar}>
          <Tabs.Tab className={classes.tab} value="appearance">
            appearance
          </Tabs.Tab>
          <Tabs.Tab className={classes.tab} value="account">
            account
          </Tabs.Tab>
          <Tabs.Tab className={classes.tab} value="files">
            files
          </Tabs.Tab>
          <Tabs.Tab className={classes.tab} value="help">
            help
          </Tabs.Tab>
        </Tabs.List>

        {/* defining the contents of each 'tab' */}
        <Tabs.Panel className={classes.panel} value="files" onClick={() => setSection('files')}>
          <ScrollArea.Autosize
            className={classes.scrollableArea}
            type="scroll"
            scrollHideDelay={100}
          >
            <Files />
          </ScrollArea.Autosize>
        </Tabs.Panel>

        <Tabs.Panel
          className={classes.panel}
          value="appearance"
          onClick={() => setSection('appearance')}
        >
          <ScrollArea.Autosize
            className={classes.scrollableArea}
            type="scroll"
            scrollHideDelay={100}
          >
            <Appearance />
          </ScrollArea.Autosize>
        </Tabs.Panel>

        <Tabs.Panel className={classes.panel} value="account" onClick={() => setSection('account')}>
          <ScrollArea.Autosize
            className={classes.scrollableArea}
            type="scroll"
            scrollHideDelay={100}
          >
            <Account />
          </ScrollArea.Autosize>
        </Tabs.Panel>

        <Tabs.Panel className={classes.panel} value="help" onClick={() => setSection('help')}>
          <ScrollArea.Autosize
            className={classes.scrollableArea}
            type="scroll"
            scrollHideDelay={100}
          >
            <Help />
          </ScrollArea.Autosize>
        </Tabs.Panel>
      </Tabs>
    </div>
  );
};
```

... which resulted in a toggle-able modal that has a heading, navbar, area for content, and an exit button:

<img src="./src/settings3.png"/>

I additionally gave the components some filler components, just give me an idea as to how each components' contents will (very roughly) look on the page - note that these don't provide any functionality, and are just a skeleton to work off of:

<img src="./src/settings2.png"/>

#### Files

Working on the Files component within settings, I started by creating a reusable set of `<div/>`s to be used for each setting 'component'...

<img src='./src/settingsComponentDiv.png'/>

... where the component is a `<div/>`, with its classname defining its role in the component, such that each setting consists of:

- `.settingComponent` - the root component, to contain the content of the setting
- `.settingsComponentTitle` - the title of the setting
- `.settingsComponentContent` - the description of the content, along with the action to be done (_i.e select the root directory_):

`SettingsModal.tsx`:

```tsx
const Files = (): JSX.Element => {
  ...
  return (
    <div>
      <div className={classes.settingComponent}>
        <Title className={classes.settingsComponentTitle} size="h3">
          header goes here
        </Title>
        <div className={classes.settingsComponentContent}>
          <Text className={classes.text}>
            description goes here
          </Text>
          <Space h="md" />
          <!-- action goes here: -->
        </div>
      </div>
    ...
  );
};
```

##### Source Folder Selector

I could then use this template to apply the 'source folder' setting, as well as any others in the future:

`SettingsModal.tsx`:

```tsx
const Files = (): JSX.Element => {
  // data provider used to keep track of the selected root directory
  const { rootDirPath, setRootDirPath } = useSharedData();
  ...
  return (
    <div>
      <Stack className={classes.stack}>
        <div className={classes.settingComponent}>
          <Title className={classes.settingsComponentTitle} size="h3">
            source folder
          </Title>
          <div className={classes.settingsComponentContent}>
            <Text className={classes.text}>
              the root directory within which your notes will be stored
            </Text>
            <Space h="md" />
            <MantineButton
              className={classes.selectFolderButton}
              variant="subtle"
              leftSection={<IconChevronDown />}
              onClick={handleDirectorySelect}
            >
              {rootDirPath || 'select directory'}
            </MantineButton>
          </div>
        </div>
        <Divider />
        ...
      </Stack>
    </div>
  );
};
```

I then added functionality to the `select directory` button in the code above by creating a function to handle the button being clicked...

`SettingsModal.tsx`:

```tsx
const Files = (): JSX.Element => {
  ...
  const handleDirectorySelect = async (): Promise<void> => {
    try {
      // asynchronously communicates with backend, so must wait for a response with `await`
      const directory = await window.ipcAPI.openDirectorySelector();
      if (directory) {
        setRootDirPath(directory);
      }
    } catch (error) {
      console.error('Failed to select directory:', error);
    }
  };
  ...
}
```

... linking to the `preload` layer...

`src/preload/index.ts`:

```ts
if (process.contextIsolated) {
  try {
    ...
    contextBridge.exposeInMainWorld('ipcAPI', {
      ...
      openDirectorySelector: () => ipcRenderer.invoke('open-directory-selector'),
      ...
    }
  }
}
...
```

... and then handling the process on the backend (`main`) by using Electron's built-in `.showOpenDialog()` method to open the file selector...

`main/index.ts`:

```ts
// listens for the request to select a directory, opens the native OS' filesystem UI and returns selected directory path
ipcMain.handle('open-directory-selector', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory'],
  });
  return result.filePaths[0];
});
```

... resulting in:

<img src="./src/settingsdirectory.gif"/>

##### Save Frequency

**_Later on in the development process_**, I came back to this feature, and I added another setting to handle the frequency of saving (_how frequently the text editor saves the contents of the file to the user's filesystem_). The options are:

- on change
- every second
- every 2s
- every 5s
- every 10s

and they determine the the time in milliseconds for the throttle handler (_the time before the `handleSaveContent()` function is called again_)

`EditNodeMetaScreen.tsx`:

```tsx
const getSaveDelay = (frequency: string): number => {
  if (frequency === 'on-change') return 0;
  return parseInt(frequency) || 2000;
};

const throttledSaveHandler = useThrottledCallback(
  handleSaveContent,
  getSaveDelay(saveFrequency || '2000')
);
```

Where the `handleSaveContent()` function uses the `.saveFile()` method I created when designing the [saving file content functionality](#file-content-saving):

`EditNodeMetaScreen.tsx`:

```tsx
const handleSaveContent = useCallback(
  async (markdown: string): Promise<void> => {
    if (!selectedTreeNodeData) return;
    try {
      await window.ipcAPI.saveFile(selectedTreeNodeData.value, markdown);
      console.log('File saved successfully');
    } catch (error) {
      console.error('Error saving file:', error);
    }
  },
  [selectedTreeNodeData]
);
```

<img src='./src/saveFrequencySelector.gif' />

##### Changes from design specification

I found that fitting the exact [UI design](../../3%20-%20Design/3.1%20-%20Design%20Part%20I/3.1.3-interface_designs.md#settings) in terms of the positioning of the 'select directory' button impossible to meet, given how the size of the button can grow to the width of the settings screen. This is because the filepath the user selects could be much longer than the originally designated area - therefore, I had to compromise by placing the button below the setting description, rather than to the right of it. **In order to maintain consistency, I made the decision to keep this design pattern for all settings components.**

#### Account

This is the section responsible for handling the user data (credentials etc.), and any changes they make to them. This requires fields for:

- username
- email
- password
- additionally there should be a profile picture, but I haven't focused on introducing that feature yet

each with their own respective logos and filler content (by default the input boxes should display the original username, email and passwords).

This also requires linking to the database so that the changes can be made permanent.

In order to modularise the code, I created a `<SubmissionForm/>` element to use, placing the functionality withing the `SubmissionForm()` function in another part of the file to increase readability and ease of use for developers...

`SettingsModal.tsx`:

```tsx
const Account = (): JSX.Element => {
  return (
    <Stack className={classes.stack}>
      <SubmissionForm />
    </Stack>
  );
};
```

... Then I defined the skeleton of the Account page, using three instances of Mantine's `<Form/>` component and their `useForm()` hook for each of username, email and password...

`SettingsModal.tsx`:

```tsx
const SubmissionForm = (): JSX.Element => {
  const [name, setName] = useState('name');
  const [email, setEmail] = useState('email');
  const [password, setPassword] = useState('password');
  const at = <IconAt size={16} stroke={1.5} />;
  const lock = <IconLock size={16} stroke={1.5} />;
  const user = <IconUser size={16} stroke={1.5} />;

  // at this point, the database is not linked to this section; the values are set to ''
  const formName = useForm({
    mode: 'uncontrolled',
    initialValues: { name: '' },
  });
  const formEmail = useForm({
    mode: 'uncontrolled',
    initialValues: { email: '' },
  });
  const formPassword = useForm({
    mode: 'uncontrolled',
    initialValues: { password: '' },
  });

  const handleSubmitName = async (values: typeof formName.values): Promise<void> => {
    await asyncSubmit(values);
    setName(values.name); // set the submitted value as the new placeholder
    formName.reset(); // reset the form to empty the input
  };
  const handleSubmitEmail = async (values: typeof formEmail.values): Promise<void> => {
    await asyncSubmit(values);
    setEmail(values.email); // set the submitted value as the new placeholder
    formEmail.reset(); // reset the form to empty the input
  };
  const handleSubmitPassword = async (values: typeof formPassword.values): Promise<void> => {
    await asyncSubmit(values);
    setPassword(values.password); // set the submitted value as the new placeholder
    formPassword.reset(); // reset the form to empty the input
  };

  return (
    <Flex align="center" gap="xl">
      <div style={{ flex: 1 }}>
        <form onSubmit={formName.onSubmit(handleSubmitName)}>
          <Flex gap="sm" justify="flex-start" align="center" direction="row" wrap="wrap">
            <TextInput
              leftSection={user}
              placeholder={name}
              key={formName.key('name')}
              {...formName.getInputProps('name')}
            />

            <Group justify="flex-end">
              <ActionIcon
                variant="transparent"
                aria-label="submit"
                type="submit"
                loaderProps={{ type: 'dots' }}
                size="lg"
              >
                <IconCornerDownLeft />
              </ActionIcon>
            </Group>
          </Flex>
        </form>

        <Space h="sm" />
        <Divider />
        <Space h="sm" />

        <form onSubmit={formEmail.onSubmit(handleSubmitEmail)}>
          <Flex gap="sm" justify="flex-start" align="center" direction="row" wrap="wrap">
            <TextInput
              leftSection={at}
              placeholder={email}
              key={formEmail.key('email')}
              {...formEmail.getInputProps('email')}
              width="100%"
            />

            <Group justify="flex-end">
              <ActionIcon
                variant="transparent"
                aria-label="submit"
                type="submit"
                loaderProps={{ type: 'dots' }}
                size="lg"
              >
                <IconCornerDownLeft />
              </ActionIcon>
            </Group>
          </Flex>
        </form>

        <Space h="sm" />
        <Divider />
        <Space h="sm" />

        <form onSubmit={formPassword.onSubmit(handleSubmitPassword)}>
          <Flex gap="sm" justify="flex-start" align="center" direction="row" wrap="wrap">
            <TextInput
              leftSection={lock}
              placeholder={password}
              key={formPassword.key('password')}
              {...formPassword.getInputProps('password')}
            />

            <Group justify="flex-end">
              <ActionIcon
                variant="transparent"
                aria-label="submit"
                type="submit"
                loaderProps={{ type: 'dots' }}
                size="lg"
              >
                {/* <IconArrowRight stroke={2} /> */}
                <IconCornerDownLeft />
              </ActionIcon>
            </Group>
          </Flex>
        </form>
      </div>
    </Flex>
  );
};
```

<img src='./src/settings6.png'/>

##### Changes from design specification

Though my initial design used the down-left arrow icon to indicate a submission button to the right of each field, once I actually had access to more icon libraries I experimented with some other icons, and considered again if they're even necessary in the UI. In the end, I decided on keeping the existing icons, as the older portion of the demographic, who aren't as necessarily as well-versed in tech, may not infer that pressing `enter` is a common form of submission in similar apps/ websites, though I believe the UI could be optimised in the future.

`SettingsModal.tsx`:

```tsx
...
<IconRightArrow />
...
<IconCornerDownLeft />
...
<IconCheck />
...
```

<img src="./src/settings5.png"/>

However, I wasn't satisfied with the positioning of the fields either. In light of [stakeholder feedback given in Iteration 2](../2.2-Iteration2/2.2.4-stakeholder_feedback.md), I needed a fluid way to incorporate the user profile picture selector into this page. This wouldn't work well with the current positioning, unless it went above or below the submission fields, which I thought wouldn't be a very cohesive design, so I experimented with moving the fields to the left and right of the page:

`SettingsModal.tsx`:

```tsx
<Flex gap="sm" justify="center" align="center" direction="row" wrap="wrap">
```

<img src="./src/settings6.png"/>

to

`SettingsModal.tsx`:

```tsx
<Flex gap="sm" justify="flex-start" align="center" direction="row" wrap="wrap">
```

<img src="./src/settings7.png"/>

to

`SettingsModal.tsx`:

```tsx
<Flex gap="sm" justify="flex-end" align="center" direction="row" wrap="wrap">
```

<img src="./src/settings8.png"/>

I decided having the profile picture selector to the left of the fields brought the design together, ensuring it's not out of the of the user's eye and mouse.

Then I worked on actually implementing the selection feature, with a default 'user' image displaying if nothing has been picked by the user. The image is selected by clicking on the profile picture circle, and navigating through the user's filesystem:

`SettingsModal.tsx`:

```tsx
const SubmissionForm = (): JSX.Element => {
  ...
  const [profileImage, setProfileImage] = useState<string | null>(null);
  ...
  const handleImageClick = async (): Promise<void> => {
    try {
      const imgData = await window.ipcAPI.openFileSelector();
      if (imgData) {
        setProfileImage(imgData);
      }
    } catch (error) {
      console.error('Failed to select image: ', error);
    }
  };
  return (
    <Flex align="center" gap="xl">
      <div className={classes.profileImg} onClick={handleImageClick}>
        {profileImage ? (
          <img
            src={profileImage}
            style={{
              width: '100%',
              height: '100%',
              objectFit: 'cover',
            }}
          />
        ) : (
          <IconUser size={60} stroke={1.5} color="var(--mantine-color-defaultScheme-1)" />
        )}
      </div>
      ...
    </Flex>
  );
};
```

`/src/renderer/src/types/index.ts`:

```tsx
export type IpcAPI = {
  ...
  openFileSelector: (options: {
    filters: Array<{ name: string; extensions: string[] }>;
  }) => Promise<string>;
  ...
};
```

`/src/preload/index.ts`:

```tsx
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI);
    // communication between front and backend for data transfer (tree node data)
    // adapted from: https://www.jsgarden.co/blog/how-to-handle-electron-ipc-events-with-typescript
    contextBridge.exposeInMainWorld('ipcAPI', {
      ...
      openFileSelector: (options) => ipcRenderer.invoke('open-file-selector', options),
      ...
    }
    ...
  }
...
}
```

`/src/main/index.ts`:

```tsx
// listens for the request to select a file, opens the native OS' filesystem UI and returns selected file path
ipcMain.handle('open-file-selector', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'Images', extensions: ['jpg', 'png', 'gif', 'jpeg'] }],
  });

  if (result.filePaths.length > 0) {
    const imgPath = result.filePaths[0];
    const imgBuffer = await readFile(imgPath);
    const base64Img = imgBuffer.toString('base64');
    const mimeType = getMimeType(imgPath);
    return `data:${mimeType};base64,${base64Img}`;
  }
  return null;
});

/* this is used to retrieve the Multi-purpose Internet Mail Extension (MIME) type of the image,
 so as to correctly encode base64 image data */
const getMimeType = (filePath: string): string => {
  const extension = filePath.toLowerCase();
  if (extension.endsWith('.png')) return 'image/png';
  if (extension.endsWith('.webp')) return 'image/webp';
  if (extension.endsWith('.svg')) return 'image/svg+xml';
  if (extension.endsWith('.gif')) return 'image/gif'; // in case the .gif type ever needs to be processed
  return 'image/jpeg'; // the default extension for .jpg, .jpeg...
};
```

<img src="./src/settings9.png"/>

- how it looks with a demo image selected

<img src="./src/settings10.png"/>

demo:

<img src="./src/settingsimage.gif"/>

discovered new syntax for styling mantine components, rather than hacking it with dev tools + `!important`:

```tsx
<NativeSelect
  classNames={{
    section: classes.nsSection,
    input: classes.nsInput,
    wrapper: classes.nsWrapper,
  }}
  ...
/>
```

#### Using a provider to share selected directory

- with sidebar
- with node network

### Home Button

Additionally, I created another component that links to the Home view, positioned next to the settings icon in the toolbar:

`HomeButton.tsx`:

```tsx
export const HomeButton = (): JSX.Element => {
  const navigate = useNavigate();
  return (
    <Button
      className={classes.homeButton}
      title="Home"
      variant="default"
      onClick={() => navigate('/home/view')}
    >
      <IconHome size={32} />
    </Button>
  );
};
```

With some basic styling:

```css
.homeButton {
  color: var(--mantine-color-defaultScheme-4);
  background-color: var(--mantine-color-defaultScheme-1);
  border-color: var(--mantine-color-defaultScheme-1);
}

.homeButton:hover {
  color: var(--mantine-color-defaultScheme-6);
  background-color: var(--mantine-color-defaultScheme-1);
}
```

<img src='./src/homeButton.png' />

## Overhauling the UI Hierarchy

Over the past 2 iterations, I've experienced some difficulties working with the way I initially designed the structure of the app and the components within it, not being able to produce some of the functionality I would like to for example because the layout does not permit it. Therefore, I decided when specifying what to work on this iteration that I needed to explicitly draw out the hierarchy of components for each main screen in the app, updating [Design Part 1](../../3%20-%20Design/3.1%20-%20Design%20Part%20I/3.1.3-interface_designs.md) accordingly.

### Home Hierarchy

<img src="./src/hierarchyhome.png"/>

### Text Editor Hierarchy

<img src="./src/hierarchytexteditor.png"/>

### Settings Hierarchy

<img src="./src/hierarchysettings.png"/>

These give me the blueprints by which to structure all the `<div />` components within each screen, from which I can then add all the functionality I wish to, in the way originally intended.

## Improving Aesthetics

The aesthetics in the app thus far are sub-par - plenty of changes need to be made to meet a reasonable standard for myself, the stakeholders and the target audience. Here I'm addressing all poor aesthetic qualities in the app, and attempt to bring them up to scratch.

### Scrollbars

In relation to the Sidebar and the filetree within it, I had no real solution to what happened when the width of the name of one of the files was wider than the SideBar. This led to unwanted behaviour:

- the names too wide not displaying all their content, and
- if the filetree was expanded below the bottom of the screen, the Sidebar grew in size as well

This led me to create 2 HTML elements for the filetree to sit within, that have custom scrollbar behaviour such that the user can scroll left to see the wider names, and down to see files off the screen - `<ScrollArea.Autosize />` to create a vertical scroll effect, and `<Box />` to provide a horizontal scroll effect:

`Sidebar.tsx`:

```tsx
export const Sidebar = (): JSX.Element => {
  return (
    ...
    <div className={classes.filetree}>
      <ScrollArea.Autosize
        className={classes.scrollableArea}
        type="scroll"
        offsetScrollbars
        viewportProps={{ style: { overflowX: 'hidden' } }}
        scrollHideDelay={100}
      >
        <Box>
          <Tree
            levelOffset="lg"
            className={classes.tree}
            selectOnClick
            clearSelectionOnOutsideClick
            data={treeNodeData ? treeNodeData : []}
            renderNode={(payload) => <Leaf {...payload} />}
          />
        </Box>
      </ScrollArea.Autosize>
    </div>
    ...
  )
  ...
}
```

I used the following CSS to style them exactly as I want, with `overflow: hidden;` meaning the horizontal scrollbar is hidden from view:

```css
.filetree {
  position: relative;
  flex: 1;
  min-height: 0;
  padding-left: 10px;
  padding-top: 4px;
  overflow: hidden;
}

.scrollableArea {
  height: 100%;
  padding-right: 10px;
  scrollbar-width: none;
}
```

<img src='./src/scrollbars.gif' />

### Manual Dynamic Resizable Sidebar

#### 'Jumping' Error

When resizing the sidebar from a width not equal to the initialised width, the sidebar jumped back to the initial width before resizing:

<img src="./src/resizeJump.gif" />
The code was:

```ts
const [sidebarWidth, setSidebarWidth] = useState(300);
const [resizing, setResizing] = useState(false);
const minWidth = 250;
const maxWidth = 450;

// function allowing the manual dynamic resizing of the sideba
const startResizing = useCallback((mouseDownEvent: React.MouseEvent) => {
  setResizing(true);
  const startX = mouseDownEvent.clientX;
  const startWidth = sidebarWidth;

  const startResizing = (mouseMoveEvent: MouseEvent): void => {
    const difference = mouseMoveEvent.clientX - startX;
    const newWidth = startWidth + difference;
    if (newWidth > minWidth && newWidth < maxWidth) {
      setSidebarWidth(newWidth);
    }
  };

  const stopResizing = (): void => {
    setResizing(false);
    window.removeEventListener('mousemove', startResizing);
    window.removeEventListener('mouseup', stopResizing);
  };

  window.addEventListener('mousemove', startResizing);
  window.addEventListener('mouseup', stopResizing);
}, []);
```

The solution:

<img src="./src/noResizeJump.gif" />

The code:

```ts
const [sidebarWidth, setSidebarWidth] = useState(300);
const [resizing, setResizing] = useState(false);
const minWidth = 250;
const maxWidth = 450;

// function allowing the manual dynamic resizing of the sideba
const startResizing = useCallback(
  (mouseDownEvent: React.MouseEvent) => {
    setResizing(true);
    const startX = mouseDownEvent.clientX;
    const startWidth = sidebarWidth;

    const startResizing = (mouseMoveEvent: MouseEvent): void => {
      const difference = mouseMoveEvent.clientX - startX;
      const newWidth = startWidth + difference;
      if (newWidth > minWidth && newWidth < maxWidth) {
        setSidebarWidth(newWidth);
      }
    };

    const stopResizing = (): void => {
      setResizing(false);
      window.removeEventListener('mousemove', startResizing);
      window.removeEventListener('mouseup', stopResizing);
    };

    window.addEventListener('mousemove', startResizing);
    window.addEventListener('mouseup', stopResizing);
  },
  [sidebarWidth]
);
```

### Removing/ Making Custom Title Bar

### Login/ Signup Design

### Text Editor

- used debugging techniques such as the dev tools (`fn`+`f12`) to isolate each div to work out where to apply the styling changes I wanted.

[insert image and gif here]

- process repeated for each change

## Network Revisions & Improvements

- note that NodeNetwork function is bulky and should be modularised/ broken down

### Adding View & Edit Modes

use draw function code, talk about several code blocks depending on the mode

redrawing dependant on updating the mode:

```ts
const draw = useCallback(() => {
  ...
}, [nodes, connections, draggingConnection, radius]);
```

to:

```ts
const draw = useCallback(() => {
  ...
}, [nodes, connections, draggingConnection, radius, mode]);
```

### Adding More Functionality to Nodes

- (view mode) right clicking opens node
- (edit mode) left clicking drags node around
- (edit mode) right clicking drags connection

### Physics

This section is only an addition I made a part of the project due to [a comment made by one of my stakeholders](../2.2-Iteration2/2.2.4-stakeholder_feedback.md#transcript-of-interview-2024), suggesting that I make the Network more interactive by adding physics to the nodes, and additionally to use an algorithm such as [Boid's Algorithm](https://en.wikipedia.org/wiki/Boids) to let the nodes move autonomously when idled.

#### Collisions

- added code to simulate collisions in `NodeNetwork.tsx`
- then added velocities, but was only applying to once mouse was let go (unclicked)
- led to me modularising and creating a separate file to contain all logic
- then had issues with chain reaction bouncing off walls
- fine tuned restitution and friction coefficients, and added mouse velocity damper
- known issue - nodes overlap and frame rate/ reload speeds mean some collisions aren't detected

#### Boid's Algorithm

- then implemented boid's algorithm, using https://people.ece.cornell.edu/land/courses/ece4760/labs/s2021/Boids/Boids.html as a reference. This involved:
  - following description/ pseudocode in website above
  - creating dropdown menu for parameters - makes development easier and quicker as well as giving the user more freedom in terms of customisability (meeting requirements set by target demographic analysis/ stakeholders)
  - tweaking parameters until suitable ranges found
  - designed so that only kicks in after 5 seconds of inactivity
  - gives user option to enable/ disable boids in settings

### Changes From Design Specification

- reconsidered colour of nodes as light pink is too bright

## Implementing an SQLite Database

### Login & Signup

- take screenshots of ui + code

```ts
import Database from 'better-sqlite3';

const database = new Database('./db/nodepad.sqlite3', {
  verbose: console.log,
});

// log all current users
database.all('SELECT * FROM Users', (err, rows) => {
  if (err) {
    console.error('Database SELECT error:', err);
    return;
  }
  console.log('Database SELECT result:', { rows });
});

// create a new record with passed in credentials if they don't already exist
export const createCredentials = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  return new Promise((resolve) => {
    console.log('createCredentials', { email, password });
    database.run('INSERT INTO Users (email, password) VALUES (?, ?)', [email, password], (err) => {
      if (err) {
        console.error('Error inserting user:', err);
        resolve({ success: false, message: err.message });
        return;
      }
      console.log('User created successfully');
      resolve({ success: true });
    });
  });
};

// check the passed in credentials to those existing in the db
export const checkCredentials = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  return new Promise((resolve) => {
    console.log('checkCredentials', { email, password });
    database.get(
      'SELECT * FROM Users WHERE email = ? AND password = ?',
      [email, password],
      (err, row) => {
        if (err) {
          console.error('Error checking credentials:', err);
          resolve({ success: false, message: err.message });
          return;
        }
        if (!row) {
          console.log('User not found');
          resolve({ success: false, message: 'Invalid email or password' });
          return;
        }
        console.log('User exists');
        resolve({ success: true });
      }
    );
  });
};
```

MIDWAY THROUGH A PACKAGE GOT UPDATED WHICH CAUSED A CONFLICT, LEADING TO THE APP NOT STARTING - THIS MEANT I HAD TO SWITCH TO THE `better-sqlite3` PACKAGE (from `sqlite3`), WHICH CHANGED HOW THE APP COMMUNICATES WITH THE DB:

```ts
import Database from 'better-sqlite3';

const database = new Database('./db/nodepad.sqlite3', {
  verbose: console.log,
});

// initialise database with a Users table if it doesn't already exist
database.exec(`
  CREATE TABLE IF NOT EXISTS Users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL
  )
`);

// log all current users
const allUsers = database.prepare('SELECT * FROM Users').all();
console.log('Current users in database:', allUsers);

// create a new record with passed in credentials if they don't already exist
export const createCredentials = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  try {
    const statement = database.prepare('INSERT INTO Users (email, password) VALUES (?, ?)');
    statement.run(email, password);
    return Promise.resolve({ success: true });
  } catch (err) {
    console.error('Error inserting user:', err);
    return Promise.resolve({ success: false, message: err.message });
  }
};

// check the passed in credentials to those existing in the db
export const checkCredentials = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  try {
    const statement = database.prepare('SELECT * FROM Users WHERE email = ? AND password = ?');
    const row = statement.get(email, password);
    if (!row) {
      return Promise.resolve({ success: false, message: 'Invalid email or password' });
    }
    return Promise.resolve({ success: true });
  } catch (err) {
    console.error('Error checking credentials:', err);
    return Promise.resolve({ success: false, message: err.message });
  }
};
```

### Account Customisation

One of the features I set out to implement was the ability to change the user's credentials from within the app, at `App -> Settings -> Account`. Currently, I had a blueprint for this, with inputs for a profile picture, username, email and password - however the changes made here did not persist, and were 'reversed' upon the user leaving Settings; no changes were made to the database.

The first thing to do was add persistent states for username and password so they could be accessed throughout the whole app via my `useSharedData()` provider. This means the app knows what credentials are assigned to this user so they can be displayed and updated within the app:

`SharedDataProvider.tsx`:

```tsx
export type SharedData = {
  ...
  email: string | undefined;
  setEmail: React.Dispatch<React.SetStateAction<string | undefined>>;
  username: string | undefined;
  setUsername: React.Dispatch<React.SetStateAction<string | undefined>>;
  password: string | undefined;
  setPassword: React.Dispatch<React.SetStateAction<string | undefined>>;
};

export function SharedDataProvider({ children }: SharedDataProviderProps): JSX.Element {
  ...
  const [email, setEmail] = useState<string>();
  const [username, setUsername] = useState<string>();
  const [password, setPassword] = useState<string>();

  const value = useMemo<SharedData>(
    () => ({
      ...
      email,
      setEmail,
      username,
      setUsername,
      password,
      setPassword,
    }),
    [
      ...
      email,
      username,
      password,
    ]
  );

  return <SharedDataContext.Provider value={value}>{children}</SharedDataContext.Provider>;
}
```

This allowed me to assign the credentials to the user when successfully logging in, leading me to update the Login code to set the credentials if, and only if, the credentials are already in the database _i.e this is a valid login_:

`LoginScreen.tsx`:

```tsx
const handleSubmit = useCallback(async (): Promise<void> => {
  const { email, password } = form.getValues();
  const result = await window.ipcAPI.checkCredentials(email, password);
  if (result) {
    // if credentials are valid, log in and assign the useSharedData() provider with user's credentials
    setEmail(email);
    setPassword(password);
    navigate('/home');
  } else {
    console.log('User not found');
    alert(
      'Invalid email or password. Please check both fields have been correctly entered, or sign up for a new account'
    );
  }
}, [form]);
```

The result is that when the user logs in and navigates to `Setting -> Account`, their username and password are displayed in their respective fields:

<img src='./src/persistentStatesLogin.gif' />

Then I attempted to implement functions to update email and password. This followed the same structure as all other front-to-backend communication, with functions being defined in `/types/index.ts`:

`/types/index.ts`

```ts
export type IpcAPI = {
  ...
  updateEmail: (oldEmail: string, newEmail: string) => Promise<boolean>;
  updatePassword: (email: string, password: string) => Promise<boolean>;
};
```

... the connection between IPCRenderer and IPCMain being established in `/preload/index.ts`, defining what should happen on the event of a success or failure to update the database:

`/preload/index.ts`:

```ts
if (process.contextIsolated) {
  try {
    ...
    // expose these functions to the backend (main):
    contextBridge.exposeInMainWorld('ipcAPI', {
      ...
      // updates email field in the record with primary key of oldEmail in db
      updateEmail: (oldEmail: string, newEmail: string) => {
        // debug
        console.log('preload:updateEmail', { oldEmail, newEmail });
        ipcRenderer.send('update-email', { oldEmail, newEmail });

        return new Promise((resolve) => {
          ipcRenderer.on('update-email-success', (_event, success) => {
            console.log('on update-email-success');
            resolve(success);
          });
          ipcRenderer.on('update-email-failure', (_event, success) => {
            console.log('on update-email-failure');
            resolve(success);
          });
        });
      },

      // updates password field in the record with primary key of email in db
      updatePassword: (email: string, password: string) => {
        // debug
        console.log('preload:updatePassword', { email, password });
        ipcRenderer.send('update-password', { email, password });

        return new Promise((resolve) => {
          ipcRenderer.on('update-password-success', (_event, success) => {
            console.log('on update-password-success');
            resolve(success);
          });
          ipcRenderer.on('update-password-failure', (_event, success) => {
            console.log('on update-password-failure');
            resolve(success);
          });
        });
      },
    ...
    }
  ...
  }
...
```

... defined what should happen upon the messages being sent from `preload` in `main`:

`main/index.ts`:

```ts
app.whenReady().then(() => {
  ...
  // new email is given...
  ipcMain.on('update-email', async (event: IpcMainEvent, { oldEmail, newEmail }) => {
    // old email is located and updated, or old email not found
    console.log('main:update-email', oldEmail, newEmail);
    const result = await checkCredentials(oldEmail, newEmail);
    result.success
      ? event.sender.send('update-email-success', result.success)
      : event.sender.send('update-email-failure', result.success);
  });

  // new password is given...
  ipcMain.on('update-password', async (event: IpcMainEvent, { email, password }) => {
    // email is located and password updated, or email not found
    console.log('main:update-password', email, password);
    const result = await updatePassword(email, password);
    result.success
      ? event.sender.send('update-password-success', result.success)
      : event.sender.send('update-password-failure', result.success);
  });
  ...
}
```

... and finally wrote the `updateEmail()` and `updatePassword()` functions within a separate file (`dbHandling.ts`), using SQLite statements to communicate with the database. In order to write these, I had to familiarise myself with the structure of SQLite statements, using [SQLite's official page](https://www.sqlitetutorial.net/sqlite-update/) as a guide:

`dbHandling.ts`:

```ts
// update the email of an existing record
export const updateEmail = (
  oldEmail: string,
  newEmail: string
): Promise<{ success: boolean; message?: string }> => {
  try {
    const statement = database.prepare('UPDATE Users SET email = ?, WHERE email = ?');
    const result = statement.run(newEmail, oldEmail);

    // if the record is not updated
    if (result.changes === 0) {
      return Promise.resolve({ success: false, message: 'email not found' });
    }
    return Promise.resolve({ success: true });
  } catch (err) {
    console.error('!! Error updating email:', err);
    return Promise.resolve({ success: false, message: 'an unknown error occurred' });
  }
};

// update the password of an existing record with given email
export const updatePassword = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  try {
    const statement = database.prepare('UPDATE Users SET password = ? WHERE email = ?');
    const result = statement.run(password, email);

    // if the record is not updated
    if (result.changes === 0) {
      return Promise.resolve({ success: false, message: 'account not found' });
    }
    return Promise.resolve({ success: true });
  } catch (err) {
    console.error('!! Error updating password:', err);
    return Promise.resolve({ success: false, message: 'an unknown error occurred' });
  }
};
```

As a result, I could use these functions within the submission of the `email` and `password` fields in `Settings -> Account` by rewriting the `handleSubmitEmail()` and `handleSubmitPassword()` functions - the functions now use `.updateEmail()` and `.updatePassword()` methods, using the awaited result to determine whether or not to update the values of `email` or `password` in the UI:

`SettingsModal.tsx`:

```tsx
const SubmissionForm = ():JSX.Element => {
  ...
  const handleSubmitEmail = async (values: typeof formEmail.values): Promise<void> => {
    const oldEmail = email || 'email'; // email could be undefined
    const result = await window.ipcAPI.updateEmail(oldEmail, values.email);
    if (result) {
      await asyncSubmit(values);
      setEmail(values.email); // set the submitted value as the new placeholder
    }
    formEmail.reset(); // reset the form to empty the input
  };

  const handleSubmitPassword = async (values: typeof formPassword.values): Promise<void> => {
    const result = await window.ipcAPI.updatePassword(
      email || 'email',
      values.password || 'password'
    ); // email and/ or password could be undefined
    if (result) {
      await asyncSubmit(values);
      setPassword(values.password); // set the submitted value as the new placeholder
    }
    formPassword.reset(); // reset the form to empty the input
  };
  ...
}
```

#### Error 1 - Incorrect Function Call

After making all these changes, I could finally test if they worked as intended. I logged in with the email 'a@b.c' and tried to change it to 'new@email.com'. This change was not reflected in the app, so I checked the debug log in the terminal and saw that the SQLite statement being executed was `'SELECT * FROM Users WHERE email = ? AND password = ?'`:

<img src='./src/firstUpdateError.gif' /> - calling wrong function in main

I recognised to be the statement used by `checkCredentials()`, and tracked down that this was being called instead of `updateEmail()` in `main/index.ts`, which I then updated:

```ts
ipcMain.on('update-email', async (event: IpcMainEvent, { oldEmail, newEmail }) => {
  ...
  const result = await updateEmail(oldEmail, newEmail); // was const result = await checkCredentials(oldEmail, newEmail)
  ...
});
```

#### Error 2 - Syntax

After resolving that error, I found that my input was still resulting in an error somewhere - again my debug log helped me by supplying me with an error message on the backend again, this time suggesting a syntactical error near the `WHERE` part of the SQLite statement:

<img src='./src/secondErrorUpdate.gif' />

After inspecting the SQLite statement in `updateEmail()` more thoroughly, I found a comma just before the `WHERE` keyword, which I had incorrectly interpreted when I was using [SQLite's guide on how to update an existing record](https://www.sqlitetutorial.net/sqlite-update/) to help write the function. I then updated the statement to exclude the comma:

`dbHandling.ts`:

```ts
export const checkCredentials = (
  email: string,
  password: string
): Promise<{ success: boolean; message?: string }> => {
  try {
    const statement = database.prepare('SELECT * FROM Users WHERE email = ? AND password = ?'); // was 'SELECT * FROM Users, WHERE email = ? AND password = ?'
    ...
  }
};
```

#### The Result

I then verified that there were no errors in the chain of communication between front and backend by inputting data into first the `email` field:

<img src='./src/workingUpdateEmail.gif' />

... and then the password field:

<img src='./src/workingUpdatePassword.gif' />

The fact that the values in the fields changed when new data was entered, along with the correctly updated credentials being logged upon restarting the app in the terminal, told me that the system was working as it should, with both the front and back end showing they worked as expected.

#### Validation

`SetingsModal.tsx`:

```tsx
const formEmail = useForm({
  mode: 'uncontrolled',
  initialValues: { email: '' },

  validate: {
    email: (value) => (/^\S+@\S+$/.test(value) ? null : 'invalid email'),
  },
});
const formPassword = useForm({
  mode: 'uncontrolled',
  initialValues: { password: '' },

  validate: {
    password: (value) => (value.length >= 8 ? null : 'invalid password'),
  },
});
```

#### Changes From Design Specification

During this process, I realised that having a username in the app is essentially redundant, as it isn't used anywhere, and would end up just making the database more complicated. Therefore, I decided to remove the `username` field from Settings. **Upon communicating this change to my stakeholders, they agreed this change was a positive one, and reduces complexity and confusion for anyone using the app who might wonder what the need for a username is:**

<img src='./src/noUsername.png' />

## Text Editor - Adding Saving

### File Content Saving

mdxEditor docs very sparse, not providing examples of usage, so I had to look into 'throttling' again (I needed this when optimising the network as well, through the use case was too different to be ble to just cross reference).

<img src="./src/mdxEditorNotHelpful.png"/>

After not much success, I made use of chatGPT to ask about how to apply the concept of 'throttling' to this problem:

<img src="./src/aiThrottlingHelp.png"/>

### File Name Saving

used similar concept, only working with a `<div/>` instead of `<MDXEditor/>`, and modifying the save times to be every time the user presses `enter`, rather than every 2000ms. Got backend functionality working with some difficulty, but issue arising when trying to open a renamed file:

<img src='./src/renameTitleOnClickError.png'>

(error occurred when clicking on the `checklist wha.md` file, which I had just renamed). After considering where the error could have arisen, I found it most likely that the culprit was in the sidebar - the filetree only updates when the root directory is changed as seen in the `useCallback()` function:

```tsx
useEffect(() => {
  if (rootDirPath) {
    window.ipcAPI.getTreeNodeData(rootDirPath).then((treeNodeData) => {
      setTreeNodeData(treeNodeData);
    });
  }
}, [rootDirPath]);
```

where the argument passed at the end of the function, `[rootDirPath]`, means the function is called if and only if the root directory is changed. This is an issue as it means any files that have their names changed won't necessarily have their names changed in the filetree - the architecture of the communication between front and back end for retrieval of file contents then means that these incorrect names can be send to the backend for content retrieval, resulting in a behaviour such that a file can be renamed once, but subsequent renamings result in error:

<img src="./src/callstack.png">

Therefore, I need to modify the callback such that the correct file names are retrieved upon any of the titles of files/ folders being changed, so the program doesn't take the wrong filename and send it to the backend to return its contents. This means updating the callback to depend on `title` as well as `rootDirPath` _i.e it will be called every time there is a change to either of those variables_:

```tsx
useEffect(() => {
  if (rootDirPath) {
    window.ipcAPI.getTreeNodeData(rootDirPath).then((treeNodeData) => {
      setTreeNodeData(treeNodeData);
    });
  }
}, [rootDirPath, title]);
```

However, since the Sidebar relies on `TreeNodeData` and thus `selectedTreeNodeData`, `selectedTreeNodeData` must also be updated with the new title - if not, the title will update, but when clicking on the renamed file in the file tree, its title will still be the original title. As a result, it will request the backend to access a file that no longer exists, as it's under a new name. This lead to me adding the following to the `handleSaveTitle` function:

```tsx
const handleSaveTitle = useCallback(
  ...
    setSelectedTreeNodeData({
      ...selectedTreeNodeData,
      value: result.path,
      label: newTitle,
    });
  [selectedTreeNodeData, setTitle, setSelectedTreeNodeData]
);
```

Upon implementing this change, I found an error was getting raised every time I renamed a file:

<img src=[gif goes here]>

Given that this happened _every time_ a new name was submitted, this had to mean that the issue was within `handleSaveTitle()`. Given that the error suggested the backend was trying to open a file named 'undefined', the data being passed from the front-end - `selectedTreeNodeData` - was also undefined. This suggested that functions were being called out of sync:

1. The file is renamed
2. `setSelectedTreeNodeData()` is called, setting value to `result.path` **before** `renameFile()` is completely executed _(the await keyword tells us it has an asynchronous response time)_
3. `renameFile()` returns result

<img src="./src/asynchronousError.png" />

Where the sequence should be:

1. The file is renamed
2. `renameFile()` returns result
3. `setSelectedTreeNodeData()` is called, setting value to `result.path`

<img src="./src/asynchronousFixed.png" />

To fix this, a new asynchronous `Promise` is called to wait one tick before continuing execution. This allows enough time for the backend to write the changes to the filename and return a result:

```tsx
await new Promise((resolve) => setTimeout(resolve, 0));
```

The result of these fixes on `handleSaveTitle()` is:

```tsx
const handleSaveTitle = useCallback(
  async (newTitle: string): Promise<void> => {
    if (!selectedTreeNodeData) return;
    try {
      const result = await window.ipcAPI.renameFile(selectedTreeNodeData.value, newTitle);
      // update the title
      setTitle(newTitle);
      // wait one tick to ensure file system operation is complete...
      await new Promise((resolve) => setTimeout(resolve, 0));
      // ...before updating the tree node data to prevent operations occurring out of sync
      setSelectedTreeNodeData({
        ...selectedTreeNodeData,
        value: result.path,
        label: newTitle,
      });
    } catch (error) {
      console.error('Error renaming file:', error);
    }
  },
  [selectedTreeNodeData, setTitle, setSelectedTreeNodeData]
);
```

This led me to think about the way nodes are rendered in the Network as well, as the nodes are rendered in a similar fashion

See next: [Stakeholder Feedback](./2.3.4-stakeholder_feedback.md)
