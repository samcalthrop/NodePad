# 2.2.3 - Annotation of Code

> _an overview & explanation of the code written to build this project - **this includes testing**_

## Errors Carried Over from Iteration 1

First thing to do this iteration is focus on fixing the errors carried over from iteration 1. At this point, the main errors are:

- MDXEditor failing to render the data passed to it
- The Sidebar component reloading with each update to the app, meaning its state is lost each time the user navigates through the app - _this means, for example, opening a file to edit it will result in the sidebar to the left losing its current state, making the app feel clunky and less usable._

### Using Providers

One way to potentially resolve the issue currently being faced restructuring app to implement my own provider - `SharedDataProvider`. **_This may be useful for both of the above errors_**, as it allows the app to re-access the state of the sidebar at any point, and also allows the MDXEditor to access the data passed to it repeatedly - my working theory is that the data is being rendered once, before it has a chance to be retrieved by the backend, but is not re-rendered once the contents are retrieved, resulting in an erroneous render message:

A provider allows data to be passed from the lower components to the top level component, in this case the `App` component. This can then be passed down the component stack to any other components that need to access the data. Therefore I can pass data from the sidebar component, to the top level app component, and then down to the MDXEditor component.

To make the provider, I:

- created a new directory `providers` to store all providers I make for the app
- created the `SharedDataProvider` directory within `providers` to store any code related to this specific provider, containing the following code within `SharedDataProvider.tsx`:

```tsx
import { createContext, useContext, useMemo, useState } from 'react';
import { TreeNodeData } from '@mantine/core';

export type SharedDataProviderProps = {
  children: React.ReactNode;
};

export type SharedData = {
  selectedTreeNodeData: TreeNodeData | undefined;
  setSelectedTreeNodeData: React.Dispatch<React.SetStateAction<TreeNodeData | undefined>>;
};

export const SharedDataContext = createContext<SharedData | undefined>(undefined);

export function SharedDataProvider({ children }: SharedDataProviderProps): JSX.Element {
  const [selectedTreeNodeData, setSelectedTreeNodeData] = useState<TreeNodeData>();

  const value = useMemo<SharedData>(
    () => ({
      selectedTreeNodeData,
      setSelectedTreeNodeData,
    }),
    [selectedTreeNodeData]
  );

  return <SharedDataContext.Provider value={value}>{children}</SharedDataContext.Provider>;
}

export const useSharedData = (): SharedData => {
  const sharedData = useContext(SharedDataContext);
  if (sharedData === undefined) {
    throw new Error('useSharedData must be used within a SharedDataProvider');
  }

  return sharedData;
};
```

#### Breaking This Down:

```tsx
export type SharedDataProviderProps = {
  children: React.ReactNode;
};
```

declares the props for the provider, which is any children of the provider;

```tsx
export type SharedData = {
  selectedTreeNodeData: TreeNodeData | undefined;
  setSelectedTreeNodeData: React.Dispatch<React.SetStateAction<TreeNodeData | undefined>>;
};
```

declares the type of data that will be shared through the provider - these use React's `useState` hook, which is a way to create a state variable (`selectedTreeNodeData`) and a function to update it (`setSelectedTreeNodeData()`).

```tsx
export const SharedDataContext = createContext<SharedData | undefined>(undefined);
```

creates a context object that can be used to communicate data across the app;

```tsx
export function SharedDataProvider({ children }: SharedDataProviderProps): JSX.Element {
  const [selectedTreeNodeData, setSelectedTreeNodeData] = useState<TreeNodeData>();

  const value = useMemo<SharedData>(
    () => ({
      selectedTreeNodeData,
      setSelectedTreeNodeData,
    }),
    [selectedTreeNodeData]
  );

  return <SharedDataContext.Provider value={value}>{children}</SharedDataContext.Provider>;
}
```

declares the provider component, which uses React's `useMemo` hook to memoize the value of the shared data, and returns a `Provider` component that wraps the app's children with the shared data context, where memoization is used to optimize performance by preventing unnecessary re-renders of components, and;

```tsx
export const useSharedData = (): SharedData => {
  const sharedData = useContext(SharedDataContext);
  if (sharedData === undefined) {
    throw new Error('useSharedData must be used within a SharedDataProvider');
  }

  return sharedData;
};
```

declares the custom hook `useSharedData()` that can be used to access the shared data within the provider.

As a result, I updated the file `Sidebar.tsx` to use the provider,

```tsx
function Leaf({
  node,
  expanded,
  hasChildren,
  elementProps,
  tree,
}: RenderTreeNodePayload): ReactElement<FileIconProps> {
  // making use of the SharedDataProvider and the custom hook useSharedData() to access the shared data
  const { setSelectedTreeNodeData } = useSharedData();
  const navigate = useNavigate();

  return (
    <Group
      gap={5}
      {...elementProps}
      onClick={() => {
        tree.toggleSelected(node.value);
        tree.toggleExpanded(node.value);
        if (!node.children) {
          console.log('Sidebar: node selected:', node);
          // updating the shared data with the selected node
          setSelectedTreeNodeData(node);
          navigate('/home/edit-node-meta');
        }
      }}
    >
      <FileIcon name={node.value} isFolder={hasChildren} expanded={expanded} />
      <span>{node.label}</span>
    </Group>
  );
}
```

and the file `src/renderer/src/index.tsx` to wrap the app in the provider (_this places the provider at the top level of the app, above the `<Routes>` component, so that any component can access the shared data_):

```tsx
ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  ...
  <SharedDataProvider>
    <HashRouter>
      <Routes>
        <Route path="/" element={<LoginScreen />} />
        <Route path="/login" element={<LoginScreen />} />
        <Route path="/signup" element={<SignUpScreen />} />
        <Route path="/home/*" element={<HomeScreen />} />
      </Routes>
    </HashRouter>
  </SharedDataProvider>
  ...
);
```

This resulted in the sidebar's state being retained when navigating through routes within the app - this is one of the two errors fixed. However, the MDXEditor was still failing to render the data passed to it - my assumption about the re-rendering was partially incorrect, and so I had to dig further to find a solution somewhere else:

### MDXEditor Methods and Refs

After carefully reviewing the `MDXEditor` [documentation](https://mdxeditor.dev/editor/docs/getting-started), I found the [methods section](https://mdxeditor.dev/editor/api/interfaces/MDXEditorMethods), detailing all methods that can be used on the MDXEditor object reference. I also found the `useMDXEditorRef` hook, which returns a ref that can be attached to the editor - this ref is what allows the editor to be updated dynamically with the data passed to it via user input. This changed the code in `EditNodeMetaScreen.tsx` to look as follows:

```tsx
...
import { MDXEditor, MDXEditorMethods, codeBlockPlugin, headingsPlugin } from '@mdxeditor/editor';
import { useEffect, useRef, useState } from 'react';
import { useSharedData } from '@renderer/providers/SharedDataProvider';

export const EditNodeMetaScreen = (): JSX.Element => {
  ...
  const { selectedTreeNodeData } = useSharedData();
  // uses a react state to get/ change the current contents of the file being edited
  const mdxEditorRef = useRef<MDXEditorMethods>(null);
  // uses a react state to get/ change the current contents of the file being edited
  const [fileContents, setFileContents] = useState<string | null>(null);

  useEffect(() => {
    console.log('EditNodeMetaScreen selectedTreeNodeData:', selectedTreeNodeData);
    if (!selectedTreeNodeData) {
      return;
    }

    window.ipcAPI.getFileContents(`./${selectedTreeNodeData.value}`).then((fileContents) => {
      console.log('EditNodeMetaScreen getFileContents:', fileContents);
      // setting the markdown of the editor to the file contents
      mdxEditorRef.current?.setMarkdown(fileContents);
      console.log(
        'EditNodeMetaScreen: mdxEditorRef.current?.getMarkdown()',
        mdxEditorRef.current?.getMarkdown()
      );
      setFileContents(fileContents);
    });
  }, [selectedTreeNodeData]);

  return (
    ...
        {fileContents === null ? (
          <div>No selection made yet</div>
        ) : (
          <div className={classes.mdxeditor}>
            {/* a class specially for the markdown editor instance, as specified in the documentation for MDXEditor: https://mdxeditor.dev/editor/docs/theming */}
            <MDXEditor
              ref={mdxEditorRef}
              className="dark-theme dark-editor"
              markdown={fileContents}
              plugins={[codeBlockPlugin(), headingsPlugin()]}
            />
          </div>
        )}
    ...
  );
};
```

### Testing (Part 1)

In order to test this functionality, I used `console.log()` intermittently to check the value of the node selected in the sidebar at various points, to ensure it was correct, and being updated as expected:

<img src="./src/statelogs.png" alt="state logs displayed in dev tools">

This also prints the contents of the file being passed to the frontend, to ensure the communication of this data is a success. The result of selecting a node looks like this:

<img src='./src/editnodemetaerror.png' alt='edit node meta render (erroneous)'/>

As we can see, the text is rendering according to the data retrieved from the backend - this is a success. However, the text is not rendering past the heading (H1) of the file. This is an error I have yet to solve.

### The Result (Part 1)

The result of these fixes is:

- The sidebar's state is retained when navigating through routes within the app, and
- MDXEditor is now rendering the data passed from the backend

<div align="center">
  <img src="./src/sidebarstate.gif" alt="Sidebar state retained when navigating through app">
</div>

**However**, there is a flaw: the data passed from the backend is not rendering past the heading (H1) of the files - I aim to fix this below:

### Plugins

After doing some further analysis, I found that the issue was actually in failing to render _the line after_ the heading, as in all the files I proceeded the heading with a quote block (`> [text]`). I found this by checking what was rendered when I placed text before the heading:

<img src='./src/rendertesting.png' alt='rendering test data'/>

which rendered, suggesting the error was not in that only the first line was being rendered, rather that it was in attempting to render the quote block.

This prompted me to revisit the [MDXEditor documentation](https://mdxeditor.dev/editor/docs/getting-started) - this led me to the plugins provided by MDXEditor as a prop for the `<MDXEditor>` component, one of which was the [quotePlugin()](https://mdxeditor.dev/editor/api/functions/quotePlugin), which "_adds support for block quotes to the editor_". Furthermore, the documentation provides plugins for rendering all other common markdown elements, such as headings, code blocks, lists, etc., which I added to the imports, and the `plugins` prop of the `<MDXEditor>` component:

```tsx
...
import {
  BlockTypeSelect,
  BoldItalicUnderlineToggles,
  CodeToggle,
  CreateLink,
  DiffSourceToggleWrapper,
  InsertImage,
  InsertTable,
  ListsToggle,
  MDXEditor,
  MDXEditorMethods,
  StrikeThroughSupSubToggles,
  UndoRedo,
  codeBlockPlugin,
  diffSourcePlugin,
  headingsPlugin,
  imagePlugin,
  jsxPlugin,
  linkDialogPlugin,
  linkPlugin,
  listsPlugin,
  markdownShortcutPlugin,
  quotePlugin,
  tablePlugin,
  toolbarPlugin,
} from '@mdxeditor/editor';

export const EditNodeMetaScreen = (): JSX.Element => {
  ...
  return (
    ...
          <div className={classes.mdxeditor}>
            {/* a class specially for the markdown editor instance, as specified in the documentation for MDXEditor: https://mdxeditor.dev/editor/docs/theming */}
            <MDXEditor
              ref={mdxEditorRef}
              className="dark-theme dark-editor"
              markdown={fileContents}
              plugins={[
                codeBlockPlugin(),
                diffSourcePlugin(),
                headingsPlugin(),
                imagePlugin(),
                jsxPlugin(),
                linkDialogPlugin(),
                linkPlugin(),
                listsPlugin(),
                markdownShortcutPlugin(),
                quotePlugin(),
                tablePlugin(),
                toolbarPlugin({
                  toolbarContents: () => (
                    <DiffSourceToggleWrapper>
                      <BlockTypeSelect />
                      <BoldItalicUnderlineToggles />
                      <StrikeThroughSupSubToggles />
                      <CreateLink />
                      <InsertImage />
                      <InsertTable />
                      <ListsToggle />
                      <CodeToggle />
                      <UndoRedo />
                    </DiffSourceToggleWrapper>
                  ),
                }),
              ]}
            />
          </div>
        )}
    ...
  );
};
```

#### Testing (Part 2)

Using this adaptation, I created a file, `checklist.md`, with all the markdown elements I want to be able to render in the app, and tested it by selecting the file in the sidebar and checking that the editor opened and correctly rendered its contents.

Upon running the program, the editor - with additional components added such as a toolbar along the top - correctly rendered all the markdown elements supplied to it by the file. Therefore this test passed, and can be considered a **success**.

Not much testing can be done for this, as my use of the MDXEditor module means any code used from the module is already tried and tested.

#### The Result (Part 2)

The result of these fixes is:

- Sidebar's state is fixed when navigating through routes within the app, and
- MDXEditor is now rendering the data passed from the backend successfully

<div align="center">
  <img src="./src/editnodemetasuccess.png" alt="successful render">
</div>

#### Demo

A demo of all the changes and fixes made thus far is summarised in the gif below:

<div align="center">
  <img src="./src/renderdemo.gif" alt="render demo">
</div>
